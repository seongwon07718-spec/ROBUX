import os, json, time, re, statistics, threading, hashlib, asyncio, base64, contextlib, sys
import discord
from discord import app_commands
from discord.ext import commands
from fastapi import FastAPI, Request
import uvicorn

# playwright ÏÇ¨Ïö© Í∞ÄÎä• Ïó¨Î∂Ä
PLAYWRIGHT_AVAILABLE = False
try:
    from playwright.async_api import async_playwright, TimeoutError as PwTimeout
    PLAYWRIGHT_AVAILABLE = True
except:
    PLAYWRIGHT_AVAILABLE = False

# ÏùºÎ∂Ä Ìò∏Ïä§Ìä∏ child watcher Î∞©Ïñ¥
try:
    if sys.platform != "win32" and hasattr(asyncio, "get_child_watcher"):
        try:
            asyncio.get_child_watcher()
        except NotImplementedError:
            from asyncio import SafeChildWatcher, set_child_watcher
            set_child_watcher(SafeChildWatcher())
except:
    pass

# ===== ÌôòÍ≤Ω =====
GUILD_ID = int(os.getenv("GUILD_ID", "1419200424636055592"))
GUILD = discord.Object(id=GUILD_ID)

GRAY = discord.Color.from_str("#808080")
RED = discord.Color.red()
GREEN = discord.Color.green()
ORANGE = discord.Color.orange()
PINK = discord.Color.from_str("#ff5ea3")

# Ïù¥Î™®ÏßÄ RAW (PartialEmojiÎ°ú ÏïàÏ†Ñ ÌååÏã±)
EMJ_NOTICE   = "<:Announcement:1423544323735027763>"
EMJ_CHARGE   = "<a:Card_Black:1423544325597560842>"
EMJ_INFO     = "<:saknagkang_00000:1371042122345484353>"
EMJ_BUY      = "<:Nitro:1423517143730749490>"
EMJ_TOSS     = "<:TOSS:1423544803559342154>"
EMJ_CULTURE  = "<:1200x630wa:1423544804721164370>"
EMJ_COIN     = "<:bitcoin:1423544805975265374>"
EMJ_APPROVE  = "<a:1209511710545813526:1421430914373779618>"
EMJ_DECLINE  = "<a:1257004507125121105:1421430917049749506>"
EMJ_HEART    = "üíå"

intents = discord.Intents.default()
intents.members = True
bot = commands.Bot(command_prefix="!", intents=intents)

# ===== DB =====
DB_PATH = "data.json"
WEBHOOK_SECRET = os.getenv("WEBHOOK_SECRET", "KBRIDGE_9f8a1c2b0e4a4a7f")
_db_lock = threading.Lock()

def _default_db():
    return {
        "categories": [],
        "products": [],  # {name, category, price, stock, items[], emoji_raw, ratings[], sold_count}
        "logs": {
            "purchase": {"enabled": False, "target_channel_id": None},
            "review":   {"enabled": False, "target_channel_id": None},
            "admin":    {"enabled": False, "target_channel_id": None},
            "secure":   {"enabled": False, "target_channel_id": None}
        },
        "payments": {"bank": False, "coin": False, "culture": False},
        "balances": {},
        "points": {},
        "orders": {},
        "account": {"bank": "", "number": "", "holder": ""},
        "bans": {},
        "reviews": {},
        "purchases_sent": {},
        "topups": {"requests": [], "receipts": []},
        "culture_accounts": {}  # {gid:{uid:{idEnc,pwEnc,options,cookies[],cookiesAt}}}
    }

def db_load():
    if not os.path.exists(DB_PATH): return _default_db()
    try:
        with open(DB_PATH, "r", encoding="utf-8") as f:
            data = json.load(f)
    except:
        return _default_db()
    base = _default_db()
    for k, v in base.items():
        data.setdefault(k, v)
    def _intmap(d):
        out = {}
        if isinstance(d, dict):
            for k, v in d.items():
                try: out[str(k)] = int(v)
                except: out[str(k)] = 0
        return out
    data["balances"] = {str(g): _intmap(u) for g, u in data.get("balances", {}).items()}
    data["points"]   = {str(g): _intmap(u) for g, u in data.get("points", {}).items()}
    for k in ("bank", "number", "holder"):
        data["account"][k] = str(data["account"].get(k, ""))
    data["topups"].setdefault("requests", [])
    data["topups"].setdefault("receipts", [])
    data.setdefault("purchases_sent", {})
    data.setdefault("culture_accounts", {})
    return data

def db_save():
    with _db_lock:
        with open(DB_PATH, "w", encoding="utf-8") as f:
            json.dump(DB, f, ensure_ascii=False, indent=2)

DB = db_load()

# ===== Ïú†Ìã∏ =====
CUSTOM_EMOJI_RE = re.compile(r'^<(?P<anim>a?):(?P<name>[A-Za-z0-9_]+):(?P<id>\d+)>$')
def parse_partial_emoji(text: str):
    if not text: return None
    m = CUSTOM_EMOJI_RE.match(text.strip())
    if not m: return None
    try:
        return discord.PartialEmoji(name=m.group("name"), id=int(m.group("id")), animated=(m.group("anim") == "a"))
    except:
        return None

def safe_emoji(raw: str | None):
    pe = parse_partial_emoji(raw or "")
    return pe if pe else None

def _now(): return int(time.time())

def set_v2(e: discord.Embed):
    try: e.set_author(name="")
    except: pass
    try: e.set_footer(text="")
    except: pass
    return e

def avg_star_value(lst: list[int]) -> float | None:
    if not lst: return None
    try: return round(statistics.mean(lst), 1)
    except: return None

def product_avg_line(p: dict) -> str:
    avg = avg_star_value(p.get("ratings", []))
    avg_txt = f"{avg:.1f}" if avg is not None else "ÏóÜÏùå"
    return f"Í∞ÄÍ≤© : {p.get('price',0)} | Ïû¨Í≥† : {p.get('stock',0)} | Î≥ÑÏ†ê : {avg_txt}"

def category_avg_txt(cat: str) -> str:
    rs = []
    for p in DB["products"]:
        if p["category"] == cat:
            rs += p.get("ratings", [])
    avg = avg_star_value(rs)
    return f"{avg:.1f}" if avg is not None else "ÏóÜÏùå"

def ban_is_blocked(gid: int, uid: int) -> bool:
    return bool(DB["bans"].get(str(gid), {}).get(str(uid), False))

def bal_get(gid: int, uid: int) -> int:
    return DB["balances"].get(str(gid), {}).get(str(uid), 0)

def bal_set(gid: int, uid: int, val: int):
    DB["balances"].setdefault(str(gid), {})
    DB["balances"][str(gid)][str(uid)] = int(val)
    db_save()

def bal_add(gid: int, uid: int, amt: int): bal_set(gid, uid, bal_get(gid, uid) + max(0, int(amt)))
def bal_sub(gid: int, uid: int, amt: int): bal_set(gid, uid, bal_get(gid, uid) - max(0, int(amt)))

def orders_get(gid: int, uid: int): return DB.get("orders", {}).get(str(gid), {}).get(str(uid), [])
def orders_add(gid: int, uid: int, product: str, qty: int):
    DB.setdefault("orders", {}).setdefault(str(gid), {}).setdefault(str(uid), []).append({"product": product, "qty": int(qty), "ts": _now()})
    db_save()

def prod_get(name: str, category: str):
    return next((p for p in DB["products"] if p["name"] == name and p["category"] == category), None)
def prod_list_by_cat(category: str): return [p for p in DB["products"] if p["category"] == category]
def prod_list_all(): return list(DB["products"])

def prod_upsert(name: str, category: str, price: int, emoji_raw: str = ""):
    p = prod_get(name, category)
    if p:
        p.update({"price": int(max(0, price)), "emoji_raw": emoji_raw})
    else:
        DB["products"].append({"name": name, "category": category, "price": int(max(0, price)), "stock": 0, "items": [], "emoji_raw": emoji_raw, "ratings": [], "sold_count": 0})
    db_save()

def prod_delete(name: str, category: str):
    DB["products"] = [p for p in DB["products"] if not (p["name"] == name and p["category"] == category)]
    db_save()

# ===== Î°úÍ∑∏ =====
def get_log_channel(guild: discord.Guild, key: str):
    cfg = DB["logs"].get(key) or {}
    if not cfg.get("enabled") or not cfg.get("target_channel_id"): return None
    ch = guild.get_channel(int(cfg["target_channel_id"]))
    return ch if isinstance(ch, discord.TextChannel) else None

async def send_log_embed(guild: discord.Guild, key: str, embed: discord.Embed):
    ch = get_log_channel(guild, key)
    if not ch: return False
    try:
        await ch.send(embed=embed); return True
    except: return False

async def send_log_text(guild: discord.Guild, key: str, text: str):
    ch = get_log_channel(guild, key)
    if not ch: return False
    try:
        await ch.send(text); return True
    except: return False

# ===== Íµ¨Îß§/ÌõÑÍ∏∞/DM =====
def emb_purchase_log(user: discord.User, product: str, qty: int):
    return set_v2(discord.Embed(title="Íµ¨Îß§Î°úÍ∑∏", description=f"{user.mention}Îãò {product} {qty}Í∞ú\nÍµ¨Îß§ Í∞êÏÇ¨Ìï©ÎãàÎã§ ÌõÑÍ∏∞ ÏûëÏÑ± Î∂ÄÌÉÅÎìúÎ¶ΩÎãàÎã§:gift_heart:", color=GRAY))

def emb_review_full(product: str, stars: int, content: str):
    line = "„Ö°"*18
    return set_v2(discord.Embed(title="Íµ¨Îß§ ÌõÑÍ∏∞", description=f"**Íµ¨Îß§Ï†úÌíà** : {product}\n**Î≥ÑÏ†ê** : {'‚≠êÔ∏è' * max(1, min(stars, 5))}\n{line}\n{content}\n{line}", color=GRAY))

def emb_purchase_dm(product: str, qty: int, price: int, items: list[str]):
    line = "„Ö°"*18
    vis = items[:20]; rest = len(items) - len(vis)
    block = "\n".join(vis) + (f"\nÏô∏ {rest}Í∞ú‚Ä¶" if rest > 0 else "")
    if not block: block = "ÌëúÏãúÌï† Ìï≠Î™©Ïù¥ ÏóÜÏäµÎãàÎã§"
    return set_v2(discord.Embed(title="Íµ¨Îß§ ÏÑ±Í≥µ", description=f"Ï†úÌíà Ïù¥Î¶Ñ : {product}\nÍµ¨Îß§ Í∞úÏàò : {qty}\nÏ∞®Í∞ê Í∏àÏï° : {price}\n{line}\n{block}", color=GREEN))

# ===== ÏûêÎèôÏ∂©Ï†Ñ(Í≥ÑÏ¢å) =====
TOPUP_TIMEOUT_SEC = 5*60
def expire_old_requests():
    now = _now(); changed = False
    for r in DB["topups"]["requests"]:
        if r.get("status", "pending") == "pending" and now - int(r.get("ts", now)) > TOPUP_TIMEOUT_SEC:
            r["status"] = "expired"; changed = True
    if changed: db_save()

def _hash_receipt(gid: int, amount: int, depositor: str):
    bucket = _now() // 10
    base = f"{gid}|{amount}|{str(depositor).lower()}|{bucket}"
    return hashlib.sha256(base.encode()).hexdigest()[:24]

async def handle_deposit(guild: discord.Guild, amount: int, depositor: str):
    expire_old_requests()
    key = _hash_receipt(guild.id, int(amount), str(depositor))
    if any(rc.get("hash") == key for rc in DB["topups"]["receipts"]): return False, "duplicate"
    now = _now()
    pending = [r for r in DB["topups"]["requests"] if r.get("status", "pending") == "pending" and r.get("guildId") == guild.id and now - int(r.get("ts", now)) <= TOPUP_TIMEOUT_SEC and int(r.get("amount", 0)) == int(amount)]
    exact = [r for r in pending if str(r.get("depositor", "")).strip().lower() == str(depositor).strip().lower()]
    exact.sort(key=lambda r: int(r.get("ts", 0)), reverse=True)
    pending.sort(key=lambda r: int(r.get("ts", 0)), reverse=True)
    target = exact[0] if exact else (pending[0] if pending else None)
    matched = None
    if target:
        matched = int(target["userId"]); target["status"] = "ok"
        bal_add(guild.id, matched, int(amount)); db_save()
        try:
            u = guild.get_member(matched) or await guild.fetch_member(matched)
            dm = await u.create_dm(); await dm.send(f"[ÏûêÎèôÏ∂©Ï†Ñ ÏôÑÎ£å]\nÍ∏àÏï°: {amount}Ïõê\nÏûÖÍ∏àÏûê: {depositor}")
        except: pass
    DB["topups"]["receipts"].append({"hash": key, "guildId": guild.id, "amount": int(amount), "depositor": str(depositor), "ts": _now(), "userId": matched}); db_save()
    return (True, "matched") if matched else (False, "queued")

# ===== Ïª¨Ï≥ê ÏÑ∏ÏÖò(Î°úÍ∑∏Ïù∏ Ïú†ÏßÄ + ÏïàÏ†ï/ÏÜçÎèÑ) =====
CULTURE_K = os.getenv("CULTURE_K", "change_me")
def _enc(s: str) -> str: return base64.b64encode((s or "").encode()).decode()
def _dec(s: str) -> str:
    try: return base64.b64decode((s or "").encode()).decode()
    except: return ""

def _save_culture_cookies(gid: int, uid: int, cookies: list[dict]):
    DB["culture_accounts"].setdefault(str(gid), {}).setdefault(str(uid), {})
    DB["culture_accounts"][str(gid)][str(uid)]["cookies"] = cookies
    DB["culture_accounts"][str(gid)][str(uid)]["cookiesAt"] = _now()
    db_save()

async def _restore_culture_cookies(context, gid: int, uid: int):
    acc = DB["culture_accounts"].get(str(gid), {}).get(str(uid), {}) or {}
    cookies = acc.get("cookies") or []
    if not cookies: return False
    try:
        await context.add_cookies(cookies); return True
    except:
        return False

def _cookies_expired(gid: int, uid: int, ttl: int = 60*60*12):
    acc = DB["culture_accounts"].get(str(gid), {}).get(str(uid), {}) or {}
    ts = int(acc.get("cookiesAt") or 0)
    return (_now() - ts) > ttl

async def culture_login_and_redeem(pin: str, gid: int, uid: int) -> tuple[bool, int, str]:
    if not PLAYWRIGHT_AVAILABLE: return False, 0, "ÏûêÎèôÌôî Î™®Îìà ÎØ∏ÏÑ§Ïπò"
    acc = DB["culture_accounts"].get(str(gid), {}).get(str(uid))
    if not acc: return False, 0, "Ïª¨Ï≥êÎûúÎìú Í≥ÑÏ†ï ÎØ∏Îì±Î°ù"
    cid = _dec(acc.get("idEnc", "")); cpw = _dec(acc.get("pwEnc", ""))
    if not cid or not cpw: return False, 0, "Í≥ÑÏ†ï Î≥µÌò∏Ìôî Ïã§Ìå®"
    p = pin.replace("-", "").replace(" ", "")
    if not p.isdigit() or len(p) not in (16, 18, 20): return False, 0, "ÌïÄ ÌòïÏãù Ïò§Î•ò"

    LOGIN_URL = "https://m.cultureland.co.kr/mmb/loginMain.do?returnUrl="
    HOME_URL  = "https://m.cultureland.co.kr/main.do"
    CHARGE_18 = "https://m.cultureland.co.kr/csh/cshGiftCard.do"
    CHARGE_16 = "https://m.cultureland.co.kr/csh/cshGiftCulture.do"
    SEL_ID    = "input[type='text'], input[name='userId']"
    SEL_PW    = "input[type='password'], input[name='passwd']"
    SEL_LOGIN = "button:has-text('Î°úÍ∑∏Ïù∏'), .btnLogin"
    SEL_4     = "input[placeholder='4ÏûêÎ¶¨']"
    SEL_6     = "input[placeholder='6ÏûêÎ¶¨']"
    SEL_SUBMIT= "button:has-text('Ï∂©Ï†ÑÌïòÍ∏∞')"

    MONEY_RE = re.compile(r"([0-9][0-9,]{2,})\s*Ïõê")
    ERR_TXT  = ["Ïù¥ÎØ∏ ÏÇ¨Ïö©", "ÏûòÎ™ªÎêú", "ÏÇ¨Ïö©Ìï† Ïàò ÏóÜÎäî", "Ï∂©Ï†Ñ Î∂àÍ∞Ä", "Ïû†Ïãú ÌõÑ Îã§Ïãú", "Ïù∏Ï¶ù Ïã§Ìå®", "ÌïúÎèÑ"]
    OK_TXT   = ["Ï∂©Ï†ÑÏù¥ ÏôÑÎ£å", "Ï∂©Ï†ÑÎêòÏóàÏäµÎãàÎã§", "Ï∂©Ï†Ñ ÏôÑÎ£å"]

    from playwright.async_api import async_playwright
    launch_kwargs = dict(headless=True, args=["--no-sandbox", "--disable-dev-shm-usage"])

    async with async_playwright() as pw:
        browser = await pw.chromium.launch(**launch_kwargs)
        context = await browser.new_context(user_agent="Mozilla/5.0 (iPhone; CPU iPhone OS 15_0 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/15.0 Mobile/15E148 Safari/604.1")
        page = await context.new_page()
        try:
            session_ok = False
            if not _cookies_expired(gid, uid):
                if await _restore_culture_cookies(context, gid, uid):
                    try:
                        await page.goto(HOME_URL, timeout=15000)
                        html = await page.content()
                        if ("Î°úÍ∑∏ÏïÑÏõÉ" in html) or ("ÎßàÏù¥ÌéòÏù¥ÏßÄ" in html) or ("ÎÇ¥ Ï†ïÎ≥¥" in html):
                            session_ok = True
                    except:
                        session_ok = False
            if not session_ok:
                await page.goto(LOGIN_URL, timeout=20000)
                id_el = await page.query_selector(SEL_ID) or (await page.query_selector_all("input"))[0]
                await id_el.fill(cid)
                pw_el = await page.query_selector(SEL_PW) or (await page.query_selector_all("input[type='password']"))[0]
                await pw_el.fill(cpw)
                btn = await page.query_selector(SEL_LOGIN) or await page.query_selector("button")
                await btn.click()
                await page.wait_for_timeout(1200)
                html = await page.content()
                if "Ï∫°Ï∞®" in html or "hCaptcha" in html: return False, 0, "Ï∫°Ï∞® Ï∞®Îã®"
                if "ÎπÑÎ∞ÄÎ≤àÌò∏" in html and "Ïò§Î•ò" in html: return False, 0, "Î°úÍ∑∏Ïù∏ Ïã§Ìå®"
                g = bot.get_guild(gid)
                if g: await send_log_text(g, "admin", f"[Ïª¨Ï≥êÎûúÎìú] Î°úÍ∑∏Ïù∏ ÏÑ±Í≥µ uid={uid}")
                try:
                    cookies = await context.cookies(); _save_culture_cookies(gid, uid, cookies)
                except: pass

            if len(p) == 18:
                await page.goto(CHARGE_18, timeout=20000)
                g1, g2, g3, g4, g5 = p[0:4], p[4:8], p[8:12], p[12:16], p[16:22]
                boxes = await page.query_selector_all(SEL_4) or await page.query_selector_all("input[maxlength='4'], input[pattern='[0-9]{4}']")
                if len(boxes) < 4: return False, 0, "18ÏûêÎ¶¨ ÏûÖÎ†•Ïπ∏ Î∂ÄÏ°±"
                await boxes[0].fill(g1); await boxes[1].fill(g2); await boxes[2].fill(g3); await boxes[3].fill(g4)
                b6 = await page.query_selector(SEL_6) or await page.query_selector("input[maxlength='6']")
                if not b6: return False, 0, "18ÏûêÎ¶¨ 6Ïπ∏ ÏóÜÏùå"
                await b6.fill(g5)
            else:
                await page.goto(CHARGE_16, timeout=20000)
                g1, g2, g3, g4 = p[0:4], p[4:8], p[8:12], p[12:16]
                boxes = await page.query_selector_all(SEL_4) or await page.query_selector_all("input[maxlength='4'], input[pattern='[0-9]{4}']")
                if len(boxes) < 4: return False, 0, "16ÏûêÎ¶¨ ÏûÖÎ†•Ïπ∏ Î∂ÄÏ°±"
                await boxes[0].fill(g1); await boxes[1].fill(g2); await boxes[2].fill(g3); await boxes[3].fill(g4)

            sb = await page.query_selector(SEL_SUBMIT) or await page.query_selector("button:has-text('Ï∂©Ï†Ñ')")
            if not sb: return False, 0, "Ï∂©Ï†Ñ Î≤ÑÌäº ÏóÜÏùå"
            await sb.click()
            await page.wait_for_timeout(1200)
            html = await page.content()
            for t in ERR_TXT:
                if t in html: return False, 0, f"Ï∂©Ï†Ñ Ïã§Ìå®: {t}"
            amt = 0
            m = MONEY_RE.search(html)
            if m:
                try: amt = int(m.group(1).replace(",", ""))
                except: amt = 0
            if any(t in html for t in OK_TXT) and amt > 0: return True, amt, ""
            await page.wait_for_timeout(800)
            html2 = await page.content()
            for t in ERR_TXT:
                if t in html2: return False, 0, f"Ï∂©Ï†Ñ Ïã§Ìå®: {t}"
            m2 = MONEY_RE.search(html2)
            if m2:
                try: amt = int(m2.group(1).replace(",", ""))
                except: amt = 0
            if any(t in html2 for t in OK_TXT) and amt > 0: return True, amt, ""
            return False, 0, "Í≤∞Í≥º ÌôïÏù∏ Ïã§Ìå®"
        except PwTimeout:
            return False, 0, "ÏùëÎãµ ÏßÄÏó∞"
        except NotImplementedError:
            return False, 0, "Ìò∏Ïä§Ìä∏ ÎØ∏ÏßÄÏõê"
        except Exception as e:
            return False, 0, f"ÏûêÎèôÌôî ÏòàÏô∏: {str(e)[:120]}"
        finally:
            try:
                cookies = await context.cookies(); _save_culture_cookies(gid, uid, cookies)
            except: pass
            with contextlib.suppress(Exception): await context.close()
            with contextlib.suppress(Exception): await browser.close()

# ===== ÌõÑÍ∏∞(1Ìöå Ï†úÌïú) =====
def can_send_review(gid: int, uid: int, key: str) -> bool:
    DB["purchases_sent"].setdefault(str(gid), {}).setdefault(str(uid), {})
    return not DB["purchases_sent"][str(gid)][str(uid)].get(key, False)

def lock_review(gid: int, uid: int, key: str):
    DB["purchases_sent"].setdefault(str(gid), {}).setdefault(str(uid), {})
    DB["purchases_sent"][str(gid)][str(uid)][key] = True
    db_save()

class ReviewSendModal(discord.ui.Modal, title="Íµ¨Îß§ ÌõÑÍ∏∞ ÏûëÏÑ±"):
    product_input = discord.ui.TextInput(label="Íµ¨Îß§ Ï†úÌíà", required=True, max_length=60)
    stars_input   = discord.ui.TextInput(label="Î≥ÑÏ†ê(1~5)", required=True, max_length=1)
    content_input = discord.ui.TextInput(label="ÌõÑÍ∏∞ ÎÇ¥Ïö©", style=discord.TextStyle.paragraph, required=True, max_length=500)
    def __init__(self, gid: int, uid: int, key: str, default_product: str = ""):
        super().__init__(); self.gid=gid; self.uid=uid; self.key=key
        if default_product: self.product_input.default = default_product
    async def on_submit(self, it: discord.Interaction):
        if not can_send_review(self.gid, self.uid, self.key):
            await it.response.send_message(embed=set_v2(discord.Embed(title="ÌõÑÍ∏∞ Ï†ÑÏÜ° Î∂àÍ∞Ä", description="Ïù¥ÎØ∏ ÏûëÏÑ±Îê®", color=PINK)), ephemeral=True); return
        s = str(self.stars_input.value).strip()
        if not s.isdigit() or not (1 <= int(s) <= 5):
            await it.response.send_message("Î≥ÑÏ†êÏùÄ 1~5 Ïà´Ïûê", ephemeral=True); return
        e = emb_review_full(str(self.product_input.value).strip(), int(s), str(self.content_input.value).strip())
        g = it.guild or bot.get_guild(GUILD_ID)
        if g: await send_log_embed(g, "review", e)
        lock_review(self.gid, self.uid, self.key)
        await it.response.send_message("ÌõÑÍ∏∞ Ï†ÑÏÜ° ÏôÑÎ£å", ephemeral=True)

class ReviewButtonView(discord.ui.View):
    def __init__(self, gid: int, uid: int, key: str, default_product: str = ""):
        super().__init__(timeout=None)
        b = discord.ui.Button(label=f"{EMJ_HEART} ÌõÑÍ∏∞ Ï†ÑÏÜ°", style=discord.ButtonStyle.secondary)
        async def _cb(i: discord.Interaction):
            if i.user.id != uid:
                await i.response.send_message("Íµ¨Îß§ÏûêÎßå Í∞ÄÎä•", ephemeral=True); return
            if not can_send_review(gid, uid, key):
                await i.response.send_message("Ïù¥ÎØ∏ ÏûëÏÑ±Îê®", ephemeral=True); return
            await i.response.send_modal(ReviewSendModal(gid, uid, key, default_product))
        b.callback = _cb; self.add_item(b)

# ===== Ï∂©Ï†Ñ(Í≥ÑÏ¢å ÏäπÏù∏/Í±∞Î∂Ä) =====
class SecureApproveView(discord.ui.View):
    def __init__(self, payload: dict):
        super().__init__(timeout=TOPUP_TIMEOUT_SEC)
        okb = discord.ui.Button(label="ÏäπÏù∏", style=discord.ButtonStyle.success, emoji=safe_emoji(EMJ_APPROVE))
        nbb = discord.ui.Button(label="Í±∞Î∂Ä", style=discord.ButtonStyle.danger,  emoji=safe_emoji(EMJ_DECLINE))
        async def _ok(i: discord.Interaction):
            await notify_user_topup_result(i.client, payload, True)
            await i.response.edit_message(embed=set_v2(discord.Embed(title="ÏäπÏù∏ ÏôÑÎ£å", description="Ìï¥Îãπ Ï∂©Ï†ÑÏã†Ï≤≠ÏùÑ ÏäπÏù∏ÌñàÏäµÎãàÎã§.", color=GREEN)), view=None)
        async def _nb(i: discord.Interaction):
            await notify_user_topup_result(i.client, payload, False)
            await i.response.edit_message(embed=set_v2(discord.Embed(title="Í±∞Î∂Ä ÏôÑÎ£å", description="Ìï¥Îãπ Ï∂©Ï†ÑÏã†Ï≤≠ÏùÑ Í±∞Î∂ÄÌñàÏäµÎãàÎã§.", color=RED)), view=None)
        okb.callback = _ok; nbb.callback = _nb
        self.add_item(okb); self.add_item(nbb)

async def notify_user_topup_result(client: discord.Client, payload: dict, approved: bool):
    gid = int(payload["guild_id"]); uid = int(payload["user_id"])
    g = client.get_guild(gid)
    if not g: return
    try:
        u = g.get_member(uid) or await g.fetch_member(uid)
        e = set_v2(discord.Embed(title=("Ï∂©Ï†ÑÏôÑÎ£å" if approved else "Ï∂©Ï†ÑÏã§Ìå®"), description=("Ï∂©Ï†ÑÏã†Ï≤≠Ïù¥ ÏÑ±Í≥µÏ†ÅÏúºÎ°ú ÏôÑÎ£åÎêòÏóàÏäµÎãàÎã§" if approved else "Ï∂©Ï†ÑÏã†Ï≤≠Ïù¥ Í±∞Î∂ÄÎêòÏóàÏäµÎãàÎã§"), color=(GREEN if approved else RED)))
        dm = await u.create_dm(); await dm.send(embed=e)
    except: pass

class PaymentModal(discord.ui.Modal, title="Ï∂©Ï†Ñ Ïã†Ï≤≠"):
    amount_input = discord.ui.TextInput(label="Ï∂©Ï†ÑÌï† Í∏àÏï°", required=True, max_length=12)
    depositor_input = discord.ui.TextInput(label="ÏûÖÍ∏àÏûêÎ™Ö", required=True, max_length=20)
    def __init__(self, owner_id: int): super().__init__(); self.owner_id = owner_id
    async def on_submit(self, it: discord.Interaction):
        try:
            amt_raw = str(self.amount_input.value).strip().replace(",", "")
            amt = int(amt_raw) if amt_raw.isdigit() else 0
            depos = str(self.depositor_input.value).strip()
            if amt > 0 and depos:
                DB["topups"]["requests"].append({"guildId": it.guild.id, "userId": it.user.id, "amount": amt, "depositor": depos, "ts": _now(), "status": "pending"})
                db_save()
        except: pass
        bank = DB["account"].get("bank", "ÎØ∏Îì±Î°ù"); holder = DB["account"].get("holder", "ÎØ∏Îì±Î°ù"); number = DB["account"].get("number", "ÎØ∏Îì±Î°ù")
        amount_txt = f"{amt_raw}Ïõê" if amt_raw else "0Ïõê"
        e = set_v2(discord.Embed(title="Ï∂©Ï†ÑÏã†Ï≤≠", description=f"ÏùÄÌñâÎ™Ö : {bank}\nÏòàÍ∏àÏ£º : {holder}\nÍ≥ÑÏ¢åÎ≤àÌò∏ : `{number}`\nÎ≥¥ÎÇ¥ÏïºÌï† Í∏àÏï° : {amount_txt}", color=GREEN))
        await it.response.send_message(embed=e, ephemeral=True)
        ch = get_log_channel(it.guild, "secure")
        if ch:
            payload = {"guild_id": it.guild.id, "user_id": it.user.id, "amount": amt, "amount_txt": amount_txt, "depositor": depos}
            e2 = set_v2(discord.Embed(title="Ï∂©Ï†ÑÏïåÎ¶º", description=f"Ïú†Ï†Ä : {it.user.mention}\nÏ∂©Ï†Ñ Í∏àÏï° : {amount_txt}\nÏûÖÍ∏àÏûêÎ™Ö : {depos}", color=ORANGE))
            await ch.send(embed=e2, view=SecureApproveView(payload))

# ===== Ïª¨Ï≥ê ÏÑ§Ï†ï/Î™®Îã¨ =====
class CultureAccountModal(discord.ui.Modal, title="Ïª¨Ï≥êÎûúÎìú ÏÑ§Ï†ï"):
    id_input = discord.ui.TextInput(label="ID", required=True, max_length=60)
    pw_input = discord.ui.TextInput(label="PW", required=True, max_length=80)
    opt_input= discord.ui.TextInput(label="ÏòµÏÖò(ÏÑ†ÌÉù)", required=False, max_length=50)
    def __init__(self, owner_id: int): super().__init__(); self.owner_id = owner_id
    async def on_submit(self, it: discord.Interaction):
        if it.user.id != self.owner_id:
            await it.response.send_message("ÏûëÏÑ±ÏûêÎßå ÏÑ§Ï†ï Í∞ÄÎä•", ephemeral=True); return
        gid = str(it.guild.id); uid = str(it.user.id)
        DB["culture_accounts"].setdefault(gid, {})
        prev = DB["culture_accounts"][gid].get(uid, {})
        DB["culture_accounts"][gid][uid] = {
            "idEnc": _enc(str(self.id_input.value).strip()),
            "pwEnc": _enc(str(self.pw_input.value).strip()),
            "options": str(self.opt_input.value).strip(),
            "cookies": prev.get("cookies", []),
            "cookiesAt": prev.get("cookiesAt", 0),
            "createdAt": prev.get("createdAt", _now()),
            "updatedAt": _now()
        }
        db_save()
        await it.response.send_message(embed=set_v2(discord.Embed(title="Ïª¨Ï≥êÎûúÎìú Í≥ÑÏ†ï Ï†ÄÏû• ÏôÑÎ£å", description="Î¨∏ÏÉÅÍ≤∞Ï†úÏóêÏÑú ÏûêÎèô ÏÇ¨Ïö©Îê©ÎãàÎã§.", color=GRAY)), ephemeral=True)

class CulturePinModal(discord.ui.Modal, title="Î¨∏ÌôîÏÉÅÌíàÍ∂å Ï∂©Ï†Ñ(Ïª¨Ï≥êÎûúÎìú)"):
    pin_input = discord.ui.TextInput(label="ÌïÄÏΩîÎìú(ÌïòÏù¥Ìîà ÏóÜÏù¥)", required=True, max_length=32)
    def __init__(self, owner_id: int): super().__init__(); self.owner_id = owner_id
    async def on_submit(self, it: discord.Interaction):
        pin = str(self.pin_input.value).strip()
        ok, amount, reason = await culture_login_and_redeem(pin, it.guild.id, it.user.id)
        if not ok or amount <= 0:
            await it.response.send_message(embed=set_v2(discord.Embed(title="Ï∂©Ï†ÑÏã§Ìå®", description=reason or "Í≤ÄÏ¶ù Ïã§Ìå®", color=RED)), ephemeral=True); return
        res, _ = await handle_deposit(it.guild, int(amount), "Î¨∏ÌôîÏÉÅÌíàÍ∂å(Ïª¨Ï≥êÎûúÎìú)")
        if res:
            await it.response.send_message(embed=set_v2(discord.Embed(title="Ï∂©Ï†ÑÏôÑÎ£å", description=f"{amount}Ïõê Ï∂©Ï†ÑÎêòÏóàÏäµÎãàÎã§", color=GREEN)), ephemeral=True)
        else:
            await it.response.send_message(embed=set_v2(discord.Embed(title="Ï∂©Ï†ÑÎåÄÍ∏∞", description="Ïû†Ïãú ÌõÑ Î∞òÏòÅÎê©ÎãàÎã§.", color=ORANGE)), ephemeral=True)

class PaymentMethodView(discord.ui.View):
    def __init__(self):
        super().__init__(timeout=None)
        if DB["payments"].get("bank", False):
            b = discord.ui.Button(label="Í≥ÑÏ¢åÏù¥Ï≤¥", style=discord.ButtonStyle.secondary, emoji=safe_emoji(EMJ_TOSS))
            async def _cb(i): await i.response.send_modal(PaymentModal(i.user.id))
            b.callback = _cb; self.add_item(b)
        if DB["payments"].get("culture", False):
            b = discord.ui.Button(label="Î¨∏ÏÉÅÍ≤∞Ï†ú", style=discord.ButtonStyle.secondary, emoji=safe_emoji(EMJ_CULTURE))
            async def _cb(i):
                if not PLAYWRIGHT_AVAILABLE:
                    await i.response.send_message("ÏûêÎèôÌôî Î™®Îìà ÎØ∏ÏÑ§Ïπò(Playwright).", ephemeral=True); return
                await i.response.send_modal(CulturePinModal(i.user.id))
            b.callback = _cb; self.add_item(b)
        if DB["payments"].get("coin", False):
            b = discord.ui.Button(label="ÏΩîÏù∏Í≤∞Ï†ú", style=discord.ButtonStyle.secondary, emoji=safe_emoji(EMJ_COIN))
            async def _cb(i): await i.response.send_message(embed=set_v2(discord.Embed(title="Ïã§Ìå®", description="ÌòÑÏû¨ ÎØ∏ÏßÄÏõê", color=RED)), ephemeral=True)
            b.callback = _cb; self.add_item(b)

# ===== Íµ¨Îß§(ÏòàÏ†Ñ Î∞©Ïãù: Î©îÏãúÏßÄ ÏàòÏ†ï ÌùêÎ¶Ñ) =====
FLOW = {}  # {gid:{uid:msg_id}}

def build_category_embed_simple():
    return set_v2(discord.Embed(title="Ïπ¥ÌÖåÍ≥†Î¶¨ ÏÑ†ÌÉùÌïòÍ∏∞", description="Ïπ¥ÌÖåÍ≥†Î¶¨Î•º ÏÑ†ÌÉùÌï¥Ï£ºÏÑ∏Ïöî", color=GRAY))

def build_product_embed_simple():
    return set_v2(discord.Embed(title="Ï†úÌíà ÏÑ†ÌÉùÌïòÍ∏∞", description="Ï†úÌíàÏùÑ ÏÑ†ÌÉùÌï¥Ï£ºÏÑ∏Ïöî", color=GRAY))

class QuantityModal(discord.ui.Modal, title="ÏàòÎüâ ÏûÖÎ†•"):
    qty_input = discord.ui.TextInput(label="Íµ¨Îß§ ÏàòÎüâ", required=True, max_length=6)
    def __init__(self, owner_id: int, category: str, product: str, msg_id: int):
        super().__init__(); self.owner_id=owner_id; self.category=category; self.product=product; self.msg_id=msg_id
    async def on_submit(self, it: discord.Interaction):
        if it.user.id != self.owner_id:
            await it.response.send_message("ÏûëÏÑ±ÏûêÎßå Í∞ÄÎä•", ephemeral=True); return
        s = str(self.qty_input.value).strip()
        if not s.isdigit() or int(s) <= 0:
            await it.response.send_message("ÏàòÎüâÏùÄ 1 Ïù¥ÏÉÅÏùò Ïà´Ïûê", ephemeral=True); return
        qty = int(s); p = prod_get(self.product, self.category)
        if not p:
            await it.response.send_message("Ïú†Ìö®ÌïòÏßÄ ÏïäÏùÄ Ï†úÌíà", ephemeral=True); return
        if p["stock"] < qty:
            await it.response.send_message(embed=set_v2(discord.Embed(title="Ïû¨Í≥† Î∂ÄÏ°±", description=f"{self.product} Ïû¨Í≥†Í∞Ä Î∂ÄÏ°±Ìï©ÎãàÎã§.", color=ORANGE)), ephemeral=True); return
        taken = []; cnt = qty
        while cnt > 0 and p["items"]:
            taken.append(p["items"].pop(0)); cnt -= 1
        p["stock"] -= qty; p["sold_count"] += qty; db_save()
        bal_sub(it.guild.id, it.user.id, p["price"] * qty)
        try:
            dm = await it.user.create_dm()
            key = f"{it.guild.id}:{it.user.id}:{self.product}:{_now()}"
            await dm.send(embed=emb_purchase_dm(self.product, qty, p["price"], taken), view=ReviewButtonView(it.guild.id, it.user.id, key, self.product))
        except: pass
        try: await send_log_embed(it.guild, "purchase", emb_purchase_log(it.user, self.product, qty))
        except: pass
        try:
            msg = await it.channel.fetch_message(self.msg_id)
            done = set_v2(discord.Embed(title="Íµ¨Îß§ ÏÑ±Í≥µ", description=f"{self.product} {qty}Í∞ú Íµ¨Îß§ ÏôÑÎ£å!\nDMÏùÑ ÌôïÏù∏Ìï¥Ï£ºÏÑ∏Ïöî.", color=GREEN))
            await msg.edit(embed=done, view=None)
        except: pass
        await it.response.send_message("Íµ¨Îß§ ÏôÑÎ£å", ephemeral=True)

class ProductSelectForMessage(discord.ui.Select):
    def __init__(self, owner_id: int, category: str, msg_id: int):
        prods = prod_list_by_cat(category)
        opts = []
        if prods:
            for p in prods[:25]:
                opts.append(discord.SelectOption(label=p["name"], value=p["name"], description=product_avg_line(p)))
        else:
            opts = [discord.SelectOption(label="Ìï¥Îãπ Ïπ¥ÌÖåÍ≥†Î¶¨Ïóê Ï†úÌíàÏù¥ ÏóÜÏäµÎãàÎã§", value="__none__")]
        super().__init__(placeholder="Ï†úÌíà ÏÑ†ÌÉùÌïòÍ∏∞", min_values=1, max_values=1, options=opts, custom_id=f"prod_sel_{owner_id}")
        self.owner_id=owner_id; self.category=category; self.msg_id=msg_id
    async def callback(self, it: discord.Interaction):
        if it.user.id != self.owner_id:
            await it.response.send_message("ÏûëÏÑ±ÏûêÎßå Í∞ÄÎä•", ephemeral=True); return
        v = self.values[0]
        if v == "__none__":
            await it.response.send_message("Î®ºÏ†Ä Ï†úÌíàÏùÑ Ï∂îÍ∞ÄÌï¥Ï£ºÏÑ∏Ïöî.", ephemeral=True); return
        await it.response.send_modal(QuantityModal(self.owner_id, self.category, v, self.msg_id))

class CategorySelectForMessage(discord.ui.Select):
    def __init__(self, owner_id: int, msg_id: int):
        cats = DB["categories"]
        if cats:
            opts = []
            for c in cats[:25]:
                opts.append(discord.SelectOption(label=c["name"], value=c["name"], description=(c.get("desc") or "")))
        else:
            opts = [discord.SelectOption(label="Îì±Î°ùÎêú Ïπ¥ÌÖåÍ≥†Î¶¨Í∞Ä ÏóÜÏäµÎãàÎã§", value="__none__")]
        super().__init__(placeholder="Ïπ¥ÌÖåÍ≥†Î¶¨ ÏÑ†ÌÉùÌïòÍ∏∞", min_values=1, max_values=1, options=opts, custom_id=f"cat_sel_{owner_id}")
        self.owner_id=owner_id; self.msg_id=msg_id
    async def callback(self, it: discord.Interaction):
        if it.user.id != self.owner_id:
            await it.response.send_message("ÏûëÏÑ±ÏûêÎßå Í∞ÄÎä•", ephemeral=True); return
        v = self.values[0]
        if v == "__none__":
            await it.response.send_message("Î®ºÏ†Ä Ïπ¥ÌÖåÍ≥†Î¶¨Î•º Ï∂îÍ∞ÄÌï¥Ï£ºÏÑ∏Ïöî.", ephemeral=True); return
        e = build_product_embed_simple()
        view = discord.ui.View(timeout=None); view.add_item(ProductSelectForMessage(self.owner_id, v, self.msg_id))
        try:
            msg = await it.channel.fetch_message(self.msg_id)
            await msg.edit(embed=e, view=view)
        except: pass
        await it.response.send_message("Ïπ¥ÌÖåÍ≥†Î¶¨ ÏÑ†ÌÉùÎê®", ephemeral=True)

class CategorySelectView(discord.ui.View):
    def __init__(self, owner_id: int, msg_id: int):
        super().__init__(timeout=None); self.add_item(CategorySelectForMessage(owner_id, msg_id))

# ===== Î≤ÑÌäº Ìå®ÎÑê =====
class ButtonPanel(discord.ui.View):
    def __init__(self):
        super().__init__(timeout=None)
        n = discord.ui.Button(label="Í≥µÏßÄÏÇ¨Ìï≠", style=discord.ButtonStyle.secondary, emoji=safe_emoji(EMJ_NOTICE), row=0)
        c = discord.ui.Button(label="Ï∂©Ï†Ñ",   style=discord.ButtonStyle.secondary, emoji=safe_emoji(EMJ_CHARGE), row=0)
        i = discord.ui.Button(label="ÎÇ¥ Ï†ïÎ≥¥", style=discord.ButtonStyle.secondary, emoji=safe_emoji(EMJ_INFO),   row=1)
        b = discord.ui.Button(label="Íµ¨Îß§",   style=discord.ButtonStyle.secondary, emoji=safe_emoji(EMJ_BUY),    row=1)
        async def _notice(it):
            await it.response.send_message(embed=set_v2(discord.Embed(title="Í≥µÏßÄÏÇ¨Ìï≠", description="ÏÑúÎ≤ÑÍ∑úÏπô ÌïÑÎèÖ Î∂ÄÌÉÅÎìúÎ¶ΩÎãàÎã§\nÏûêÏ∂© Ïò§Î•òÏãú Ìã∞Ïºì Ïó¥Ïñ¥Ï£ºÏÑ∏Ïöî", color=GRAY)), ephemeral=True)
        async def _charge(it):
            if ban_is_blocked(it.guild.id, it.user.id):
                await it.response.send_message(embed=set_v2(discord.Embed(title="Ïù¥Ïö© Î∂àÍ∞Ä", description="Ï∞®Îã® ÏÉÅÌÉúÏûÖÎãàÎã§. /Ïú†Ï†Ä_ÏÑ§Ï†ïÏúºÎ°ú Ìï¥Ï†úÌïòÏÑ∏Ïöî.", color=RED)), ephemeral=True); return
            e = set_v2(discord.Embed(title="Í≤∞Ï†úÏàòÎã® ÏÑ†ÌÉùÌïòÍ∏∞", description="ÏõêÌïòÏãúÎäî Í≤∞Ï†úÏàòÎã® Î≤ÑÌäºÏùÑ ÌÅ¥Î¶≠Ìï¥Ï£ºÏÑ∏Ïöî", color=GRAY))
            await it.response.send_message(embed=e, view=PaymentMethodView(), ephemeral=True)
        async def _info(it):
            gid=it.guild.id; uid=it.user.id
            ords=orders_get(gid,uid); spent=0
            for o in ords:
                p=next((pp for pp in DB["products"] if pp["name"]==o["product"]), None)
                if p: spent += p["price"]*o["qty"]
            bal=bal_get(gid,uid); pts=DB["points"].get(str(gid),{}).get(str(uid),0)
            line="„Ö°"*18
            desc=f"Î≥¥Ïú† Í∏àÏï° : {bal}\nÎàÑÏ†Å Í∏àÏï° : {spent}\nÌè¨Ïù∏Ìä∏ : {pts}\nÍ±∞Îûò ÌöüÏàò : {len(ords)}\n{line}\nÏó≠Ìï†Îì±Í∏â : ÏïÑÏßÅ ÏóÜÏäµÎãàÎã§\nÏó≠Ìï†ÌòúÌÉù : ÏïÑÏßÅ ÏóÜÏäµÎãàÎã§"
            e=set_v2(discord.Embed(title="ÎÇ¥ Ï†ïÎ≥¥", description=desc, color=GRAY))
            try: e.set_thumbnail(url=it.user.display_avatar.url)
            except: pass
            await it.response.send_message(embed=e, ephemeral=True)
        async def _buy(it):
            if ban_is_blocked(it.guild.id, it.user.id):
                await it.response.send_message(embed=set_v2(discord.Embed(title="Ïù¥Ïö© Î∂àÍ∞Ä", description="Ï∞®Îã® ÏÉÅÌÉúÏûÖÎãàÎã§. /Ïú†Ï†Ä_ÏÑ§Ï†ïÏúºÎ°ú Ìï¥Ï†úÌïòÏÑ∏Ïöî.", color=RED)), ephemeral=True); return
            e = build_category_embed_simple()
            await it.response.send_message(embed=e, ephemeral=False)
            msg = await it.original_response()
            FLOW.setdefault(str(it.guild.id), {})[str(it.user.id)] = msg.id
            try: await msg.edit(view=CategorySelectView(it.user.id, msg.id))
            except: pass
        n.callback=_notice; c.callback=_charge; i.callback=_info; b.callback=_buy
        self.add_item(n); self.add_item(c); self.add_item(i); self.add_item(b)

# ===== Í¥ÄÎ¶¨Ïûê Î≥¥Ìò∏ =====
def is_admin():
    async def predicate(interaction: discord.Interaction):
        if interaction.user.guild_permissions.manage_guild: return True
        await interaction.response.send_message("Í¥ÄÎ¶¨ÏûêÎßå ÏÇ¨Ïö©Ìï† Ïàò ÏûàÏñ¥.", ephemeral=True)
        return False
    return app_commands.check(predicate)

# ===== Ïä¨ÎûòÏãú Î™ÖÎ†πÏñ¥(11Í∞ú) =====
class CategoryDeleteView(discord.ui.View):
    def __init__(self, owner_id: int):
        super().__init__(timeout=None)
        class Sel(discord.ui.Select):
            def __init__(self, owner_id: int):
                cats = DB["categories"]; opts=[]
                for c in cats[:25]:
                    opts.append(discord.SelectOption(label=c["name"], value=c["name"], description=(c.get("desc") or "")))
                super().__init__(placeholder="ÏÇ≠Ï†úÌï† Ïπ¥ÌÖåÍ≥†Î¶¨ ÏÑ†ÌÉù", min_values=1, max_values=1, options=opts or [discord.SelectOption(label="ÏÇ≠Ï†úÌï† Ïπ¥ÌÖåÍ≥†Î¶¨Í∞Ä ÏóÜÏäµÎãàÎã§", value="__none__")], custom_id=f"cat_del_{owner_id}")
                self.owner_id=owner_id
            async def callback(self, it: discord.Interaction):
                if it.user.id != self.owner_id:
                    await it.response.send_message("ÏûëÏÑ±ÏûêÎßå Í∞ÄÎä•", ephemeral=True); return
                v = self.values[0]
                if v == "__none__":
                    await it.response.send_message("ÏÇ≠Ï†úÌï† Ïπ¥ÌÖåÍ≥†Î¶¨Í∞Ä ÏóÜÏäµÎãàÎã§.", ephemeral=True); return
                DB["categories"] = [c for c in DB["categories"] if c["name"] != v]
                DB["products"]   = [p for p in DB["products"] if p["category"] != v]; db_save()
                await it.response.send_message(embed=set_v2(discord.Embed(title="Ïπ¥ÌÖåÍ≥†Î¶¨ ÏÇ≠Ï†ú ÏôÑÎ£å", description=f"ÏÇ≠Ï†úÎêú Ïπ¥ÌÖåÍ≥†Î¶¨: {v}", color=GRAY)), ephemeral=True)
        self.add_item(Sel(owner_id))

class CategorySetupModal(discord.ui.Modal, title="Ïπ¥ÌÖåÍ≥†Î¶¨ Ï∂îÍ∞Ä"):
    name_input = discord.ui.TextInput(label="Ïπ¥ÌÖåÍ≥†Î¶¨ Ïù¥Î¶Ñ", required=True, max_length=60)
    desc_input = discord.ui.TextInput(label="Ïπ¥ÌÖåÍ≥†Î¶¨ ÏÑ§Î™Ö", style=discord.TextStyle.paragraph, required=False, max_length=200)
    emoji_input= discord.ui.TextInput(label="Ïπ¥ÌÖåÍ≥†Î¶¨ Ïù¥Î™®ÏßÄ", required=False, max_length=100)
    def __init__(self, owner_id: int): super().__init__(); self.owner_id=owner_id
    async def on_submit(self, it: discord.Interaction):
        if it.user.id != self.owner_id:
            await it.response.send_message("ÏûëÏÑ±ÏûêÎßå Í∞ÄÎä•", ephemeral=True); return
        name=str(self.name_input.value).strip(); desc=str(self.desc_input.value).strip() if self.desc_input.value else ""; emoji=str(self.emoji_input.value).strip() if self.emoji_input.value else ""
        i = next((k for k, c in enumerate(DB["categories"]) if c["name"] == name), -1)
        row={"name": name, "desc": desc, "emoji_raw": emoji}
        if i >= 0: DB["categories"][i] = row
        else: DB["categories"].append(row)
        db_save()
        await it.response.send_message(embed=set_v2(discord.Embed(title="Ïπ¥ÌÖåÍ≥†Î¶¨ Îì±Î°ù ÏôÑÎ£å", description=f"{name}\n{desc}", color=GRAY)), ephemeral=True)

class StockAddModal(discord.ui.Modal, title="Ïû¨Í≥† Ï∂îÍ∞Ä"):
    lines_input = discord.ui.TextInput(label="Ïû¨Í≥† Ï∂îÍ∞Ä(Ï§ÑÎßàÎã§ 1Í∞ú)", style=discord.TextStyle.paragraph, required=True, max_length=4000)
    def __init__(self, owner_id: int, name: str, category: str): super().__init__(); self.owner_id=owner_id; self.name=name; self.category=category
    async def on_submit(self, it: discord.Interaction):
        if it.user.id != self.owner_id:
            await it.response.send_message("ÏûëÏÑ±ÏûêÎßå Í∞ÄÎä•", ephemeral=True); return
        lines = [ln.strip() for ln in str(self.lines_input.value).splitlines() if ln.strip()]
        p = prod_get(self.name, self.category)
        if not p:
            await it.response.send_message("Ïú†Ìö®ÌïòÏßÄ ÏïäÏùÄ Ï†úÌíàÏûÖÎãàÎã§.", ephemeral=True); return
        p["items"].extend(lines); p["stock"] += len(lines); db_save()
        await it.response.send_message(embed=set_v2(discord.Embed(title="Ïû¨Í≥† Ï∂îÍ∞Ä ÏôÑÎ£å", description=f"{self.name} +{len(lines)} ‚Üí Ïû¨Í≥† {p['stock']}", color=GRAY)), ephemeral=True)

class ProductSetupModal(discord.ui.Modal, title="Ï†úÌíà Ï∂îÍ∞Ä"):
    name_input = discord.ui.TextInput(label="Ï†úÌíà Ïù¥Î¶Ñ", required=True, max_length=60)
    category_input = discord.ui.TextInput(label="Ïπ¥ÌÖåÍ≥†Î¶¨ Ïù¥Î¶Ñ", required=True, max_length=60)
    price_input = discord.ui.TextInput(label="Ï†úÌíà Í∞ÄÍ≤©(Ïõê)", required=True, max_length=10)
    emoji_input  = discord.ui.TextInput(label="Ï†úÌíà Ïù¥Î™®ÏßÄ", required=False, max_length=100)
    def __init__(self, owner_id: int): super().__init__(); self.owner_id=owner_id
    async def on_submit(self, it: discord.Interaction):
        if it.user.id != self.owner_id:
            await it.response.send_message("ÏûëÏÑ±ÏûêÎßå Í∞ÄÎä•", ephemeral=True); return
        name=str(self.name_input.value).strip(); cat=str(self.category_input.value).strip(); price_s=str(self.price_input.value).strip()
        if not any(c["name"]==cat for c in DB["categories"]):
            await it.response.send_message("Ìï¥Îãπ Ïπ¥ÌÖåÍ≥†Î¶¨Í∞Ä ÏóÜÏäµÎãàÎã§.", ephemeral=True); return
        if not price_s.isdigit():
            await it.response.send_message("Í∞ÄÍ≤©ÏùÄ Ïà´ÏûêÎßå ÏûÖÎ†•", ephemeral=True); return
        price=int(price_s); emoji=str(self.emoji_input.value).strip() if self.emoji_input.value else ""
        prod_upsert(name, cat, price, emoji)
        await it.response.send_message(embed=set_v2(discord.Embed(title="Ï†úÌíà Îì±Î°ù ÏôÑÎ£å", description=f"{name}\nÏπ¥ÌÖåÍ≥†Î¶¨: {cat}\nÍ∞ÄÍ≤©: {price}", color=GRAY)), ephemeral=True)

class ProductDeleteView(discord.ui.View):
    def __init__(self, owner_id: int):
        super().__init__(timeout=None)
        class Sel(discord.ui.Select):
            def __init__(self, owner_id: int):
                ps = prod_list_all(); opts=[]
                for p in ps[:25]:
                    opts.append(discord.SelectOption(label=p["name"], value=f"{p['name']}||{p['category']}", description=f"{p['category']}"))
                super().__init__(placeholder="ÏÇ≠Ï†úÌï† Ï†úÌíà ÏÑ†ÌÉù", min_values=1, max_values=1, options=opts or [discord.SelectOption(label="ÏÇ≠Ï†úÌï† Ï†úÌíàÏù¥ ÏóÜÏäµÎãàÎã§", value="__none__")], custom_id=f"prod_del_{owner_id}")
                self.owner_id=owner_id
            async def callback(self, it: discord.Interaction):
                if it.user.id != self.owner_id:
                    await it.response.send_message("ÏûëÏÑ±ÏûêÎßå Í∞ÄÎä•", ephemeral=True); return
                v = self.values[0]
                if v == "__none__":
                    await it.response.send_message("ÏÇ≠Ï†úÌï† Ï†úÌíàÏù¥ ÏóÜÏäµÎãàÎã§.", ephemeral=True); return
                name,cat = v.split("||",1); prod_delete(name, cat)
                await it.response.send_message(embed=set_v2(discord.Embed(title="Ï†úÌíà ÏÇ≠Ï†ú ÏôÑÎ£å", description=f"ÏÇ≠Ï†úÎêú Ï†úÌíà: {name} (Ïπ¥ÌÖåÍ≥†Î¶¨: {cat})", color=GRAY)), ephemeral=True)
        self.add_item(Sel(owner_id))

class ControlCog(commands.Cog):
    def __init__(self, bot_: commands.Bot): self.bot = bot_

    @app_commands.command(name="Î≤ÑÌäºÌå®ÎÑê", description="Î≤ÑÌäº Ìå®ÎÑê")
    @app_commands.guilds(GUILD)
    async def Î≤ÑÌäºÌå®ÎÑê(self, it: discord.Interaction):
        await it.response.send_message(embed=set_v2(discord.Embed(title="ÏúàÎìú OTT", description="ÏïÑÎûò Î≤ÑÌäºÏúºÎ°ú Ïù¥Ïö©Ìï¥Ï£ºÏÑ∏Ïöî!", color=GRAY)), view=ButtonPanel())

    @app_commands.command(name="Ïπ¥ÌÖåÍ≥†Î¶¨_ÏÑ§Ï†ï", description="Ïπ¥ÌÖåÍ≥†Î¶¨ ÏÑ§Ï†ï")
    @app_commands.guilds(GUILD)
    @is_admin()
    async def Ïπ¥ÌÖåÍ≥†Î¶¨_ÏÑ§Ï†ï(self, it: discord.Interaction):
        v = discord.ui.View(timeout=None)
        class Root(discord.ui.Select):
            def __init__(self, owner_id: int):
                super().__init__(placeholder="Ïπ¥ÌÖåÍ≥†Î¶¨ ÏÑ§Ï†ïÌïòÍ∏∞", min_values=1, max_values=1, options=[discord.SelectOption(label="Ïπ¥ÌÖåÍ≥†Î¶¨ Ï∂îÍ∞Ä", value="add"), discord.SelectOption(label="Ïπ¥ÌÖåÍ≥†Î¶¨ ÏÇ≠Ï†ú", value="del")], custom_id=f"cat_root_{owner_id}")
                self.owner_id=owner_id
            async def callback(self, inter: discord.Interaction):
                if inter.user.id != self.owner_id:
                    await inter.response.send_message("ÏûëÏÑ±ÏûêÎßå Í∞ÄÎä•", ephemeral=True); return
                if self.values[0] == "add": await inter.response.send_modal(CategorySetupModal(self.owner_id))
                else: await inter.response.send_message(embed=set_v2(discord.Embed(title="Ïπ¥ÌÖåÍ≥†Î¶¨ ÏÇ≠Ï†ú", description="ÏÇ≠Ï†úÌï† Ïπ¥ÌÖåÍ≥†Î¶¨Î•º ÏÑ†ÌÉùÌïòÏÑ∏Ïöî.", color=GRAY)), view=CategoryDeleteView(self.owner_id), ephemeral=True)
        v.add_item(Root(it.user.id))
        await it.response.send_message(embed=set_v2(discord.Embed(title="Ïπ¥ÌÖåÍ≥†Î¶¨ ÏÑ§Ï†ïÌïòÍ∏∞", description="Ïπ¥ÌÖåÍ≥†Î¶¨ ÏÑ§Ï†ïÌï¥Ï£ºÏÑ∏Ïöî", color=GRAY)), view=v, ephemeral=True)

    @app_commands.command(name="Ï†úÌíà_ÏÑ§Ï†ï", description="Ï†úÌíà ÏÑ§Ï†ï")
    @app_commands.guilds(GUILD)
    @is_admin()
    async def Ï†úÌíà_ÏÑ§Ï†ï(self, it: discord.Interaction):
        v = discord.ui.View(timeout=None)
        class Root(discord.ui.Select):
            def __init__(self, owner_id: int):
                super().__init__(placeholder="Ï†úÌíà ÏÑ§Ï†ïÌïòÍ∏∞", min_values=1, max_values=1, options=[discord.SelectOption(label="Ï†úÌíà Ï∂îÍ∞Ä", value="add"), discord.SelectOption(label="Ï†úÌíà ÏÇ≠Ï†ú", value="del")], custom_id=f"prod_root_{owner_id}")
                self.owner_id=owner_id
            async def callback(self, inter: discord.Interaction):
                if inter.user.id != self.owner_id:
                    await inter.response.send_message("ÏûëÏÑ±ÏûêÎßå Í∞ÄÎä•", ephemeral=True); return
                if self.values[0] == "add": await inter.response.send_modal(ProductSetupModal(self.owner_id))
                else: await inter.response.send_message(embed=set_v2(discord.Embed(title="Ï†úÌíà ÏÇ≠Ï†ú", description="ÏÇ≠Ï†úÌï† Ï†úÌíàÏùÑ ÏÑ†ÌÉùÌïòÏÑ∏Ïöî.", color=GRAY)), view=ProductDeleteView(self.owner_id), ephemeral=True)
        v.add_item(Root(it.user.id))
        await it.response.send_message(embed=set_v2(discord.Embed(title="Ï†úÌíà ÏÑ§Ï†ïÌïòÍ∏∞", description="Ï†úÌíà ÏÑ§Ï†ïÌï¥Ï£ºÏÑ∏Ïöî", color=GRAY)), view=v, ephemeral=True)

    @app_commands.command(name="Ïû¨Í≥†_ÏÑ§Ï†ï", description="Ïû¨Í≥† ÏÑ§Ï†ï")
    @app_commands.guilds(GUILD)
    @is_admin()
    async def Ïû¨Í≥†_ÏÑ§Ï†ï(self, it: discord.Interaction):
        class Sel(discord.ui.Select):
            def __init__(self, owner_id: int):
                ps = prod_list_all(); opts=[]
                if ps:
                    for p in ps[:25]:
                        opts.append(discord.SelectOption(label=f"{p['name']} ({p['category']})", value=f"{p['name']}||{p['category']}", description=f"Í∞ÄÍ≤© {p['price']}"))
                else:
                    opts = [discord.SelectOption(label="Îì±Î°ùÎêú Ï†úÌíàÏù¥ ÏóÜÏäµÎãàÎã§", value="__none__")]
                super().__init__(placeholder="Ïû¨Í≥†Î•º ÏÑ§Ï†ïÌï† Ï†úÌíàÏùÑ ÏÑ†ÌÉù", min_values=1, max_values=1, options=opts, custom_id=f"stock_prod_{owner_id}")
                self.owner_id=owner_id
            async def callback(self, inter: discord.Interaction):
                if inter.user.id != self.owner_id:
                    await inter.response.send_message("ÏûëÏÑ±ÏûêÎßå Í∞ÄÎä•", ephemeral=True); return
                v = self.values[0]
                if v == "__none__":
                    await inter.response.send_message("Î®ºÏ†Ä Ï†úÌíàÏùÑ Ï∂îÍ∞ÄÌï¥Ï£ºÏÑ∏Ïöî.", ephemeral=True); return
                name,cat = v.split("||",1); await inter.response.send_modal(StockAddModal(self.owner_id, name, cat))
        view = discord.ui.View(timeout=None); view.add_item(Sel(it.user.id))
        await it.response.send_message(embed=set_v2(discord.Embed(title="Ïû¨Í≥† ÏÑ§Ï†ïÌïòÍ∏∞", description="Ïû¨Í≥† ÏÑ§Ï†ïÌï¥Ï£ºÏÑ∏Ïöî", color=GRAY)), view=view, ephemeral=True)

    @app_commands.command(name="Î°úÍ∑∏_ÏÑ§Ï†ï", description="Î°úÍ∑∏/Î≥¥Ïïà Ï±ÑÎÑê ÏÑ§Ï†ï")
    @app_commands.guilds(GUILD)
    @is_admin()
    async def Î°úÍ∑∏_ÏÑ§Ï†ï(self, it: discord.Interaction):
        class Modal(discord.ui.Modal, title="Î°úÍ∑∏ Ï±ÑÎÑê ÏÑ§Ï†ï"):
            channel_id_input = discord.ui.TextInput(label="Ï±ÑÎÑê ID", required=True, max_length=25)
            def __init__(self, owner_id: int, key: str): super().__init__(); self.owner_id=owner_id; self.key=key
            async def on_submit(self, inter: discord.Interaction):
                if inter.user.id != self.owner_id:
                    await inter.response.send_message("ÏûëÏÑ±ÏûêÎßå Í∞ÄÎä•", ephemeral=True); return
                raw = str(self.channel_id_input.value).strip()
                if not raw.isdigit():
                    await inter.response.send_message(embed=set_v2(discord.Embed(title="Ïã§Ìå®", description="Ï±ÑÎÑê IDÎäî Ïà´Ïûê", color=RED)), ephemeral=True); return
                ch = inter.guild.get_channel(int(raw))
                if not isinstance(ch, discord.TextChannel):
                    await inter.response.send_message(embed=set_v2(discord.Embed(title="Ïã§Ìå®", description="Ïú†Ìö®Ìïú ÌÖçÏä§Ìä∏ Ï±ÑÎÑê ÏïÑÎãò", color=RED)), ephemeral=True); return
                DB["logs"].setdefault(self.key, {"enabled": False, "target_channel_id": None})
                DB["logs"][self.key]["target_channel_id"] = int(raw); DB["logs"][self.key]["enabled"] = True; db_save()
                pretty = {"purchase":"Íµ¨Îß§Î°úÍ∑∏","review":"Íµ¨Îß§ÌõÑÍ∏∞","admin":"Í¥ÄÎ¶¨ÏûêÎ°úÍ∑∏","secure":"Î≥¥ÏïàÏ±ÑÎÑê"}[self.key]
                await inter.response.send_message(embed=set_v2(discord.Embed(title=f"{pretty} Ï±ÑÎÑê ÏßÄÏ†ï ÏôÑÎ£å", description=f"Î™©Ï†ÅÏßÄ: {ch.mention}", color=GRAY)), ephemeral=True)
        class Root(discord.ui.Select):
            def __init__(self, owner_id: int):
                opts=[discord.SelectOption(label="Íµ¨Îß§Î°úÍ∑∏ ÏÑ§Ï†ï", value="purchase"), discord.SelectOption(label="Íµ¨Îß§ÌõÑÍ∏∞ ÏÑ§Ï†ï", value="review"), discord.SelectOption(label="Í¥ÄÎ¶¨ÏûêÎ°úÍ∑∏ ÏÑ§Ï†ï", value="admin"), discord.SelectOption(label="Î≥¥ÏïàÏ±ÑÎÑê ÏÑ§Ï†ï(Ï∂©Ï†ÑÏäπÏù∏)", value="secure")]
                super().__init__(placeholder="ÏÑ§Ï†ïÌï† Î°úÍ∑∏ Ïú†Ìòï ÏÑ†ÌÉù", min_values=1, max_values=1, options=opts, custom_id=f"log_root_{owner_id}")
                self.owner_id=owner_id
            async def callback(self, inter: discord.Interaction):
                if inter.user.id != self.owner_id:
                    await inter.response.send_message("ÏûëÏÑ±ÏûêÎßå Í∞ÄÎä•", ephemeral=True); return
                await inter.response.send_modal(Modal(self.owner_id, self.values[0]))
        view = discord.ui.View(timeout=None); view.add_item(Root(it.user.id))
        await it.response.send_message(embed=set_v2(discord.Embed(title="Î°úÍ∑∏ ÏÑ§Ï†ïÌïòÍ∏∞", description="Î°úÍ∑∏/Î≥¥Ïïà Ï±ÑÎÑêÏùÑ ÏÑ§Ï†ïÌï¥Ï£ºÏÑ∏Ïöî", color=GRAY)), view=view, ephemeral=True)

    @app_commands.command(name="ÏûîÏï°_ÏÑ§Ï†ï", description="ÏûîÏï° Ï∂îÍ∞Ä/Ï∞®Í∞ê")
    @app_commands.guilds(GUILD)
    @is_admin()
    @app_commands.describe(Ïú†Ï†Ä="ÎåÄÏÉÅ Ïú†Ï†Ä", Í∏àÏï°="Ï†ïÏàò Í∏àÏï°", Ïó¨Î∂Ä="Ï∂îÍ∞Ä/Ï∞®Í∞ê")
    @app_commands.choices(Ïó¨Î∂Ä=[app_commands.Choice(name="Ï∂îÍ∞Ä", value="Ï∂îÍ∞Ä"), app_commands.Choice(name="Ï∞®Í∞ê", value="Ï∞®Í∞ê")])
    async def ÏûîÏï°_ÏÑ§Ï†ï(self, it: discord.Interaction, Ïú†Ï†Ä: discord.Member, Í∏àÏï°: int, Ïó¨Î∂Ä: app_commands.Choice[str]):
        if Í∏àÏï° < 0:
            await it.response.send_message("Í∏àÏï°ÏùÄ ÏùåÏàò Î∂àÍ∞Ä", ephemeral=True); return
        gid=it.guild.id; uid=Ïú†Ï†Ä.id; prev=bal_get(gid, uid)
        if Ïó¨Î∂Ä.value == "Ï∞®Í∞ê":
            bal_sub(gid, uid, Í∏àÏï°); after=bal_get(gid, uid); color=RED; title=f"{Ïú†Ï†Ä} Í∏àÏï° Ï∞®Í∞ê"
        else:
            bal_add(gid, uid, Í∏àÏï°); after=bal_get(gid, uid); color=GREEN; title=f"{Ïú†Ï†Ä} Í∏àÏï° Ï∂îÍ∞Ä"
        await it.response.send_message(embed=set_v2(discord.Embed(title=title, description=f"ÏõêÎûò Í∏àÏï° : {prev}\nÎ≥ÄÍ≤Ω Í∏àÏï° : {Í∏àÏï°}\nÎ≥ÄÍ≤Ω ÌõÑ Í∏àÏï° : {after}", color=color)), ephemeral=True)

    @app_commands.command(name="Í≤∞Ï†úÏàòÎã®_ÏÑ§Ï†ï", description="Í≤∞Ï†úÏàòÎã® ÏßÄÏõê Ïó¨Î∂Ä")
    @app_commands.guilds(GUILD)
    @is_admin()
    @app_commands.describe(Í≥ÑÏ¢åÏù¥Ï≤¥="ÏßÄÏõê/ÎØ∏ÏßÄÏõê", ÏΩîÏù∏Í≤∞Ï†ú="ÏßÄÏõê/ÎØ∏ÏßÄÏõê", Î¨∏ÏÉÅÍ≤∞Ï†ú="ÏßÄÏõê/ÎØ∏ÏßÄÏõê")
    @app_commands.choices(
        Í≥ÑÏ¢åÏù¥Ï≤¥=[app_commands.Choice(name="ÏßÄÏõê", value="ÏßÄÏõê"), app_commands.Choice(name="ÎØ∏ÏßÄÏõê", value="ÎØ∏ÏßÄÏõê")],
        ÏΩîÏù∏Í≤∞Ï†ú=[app_commands.Choice(name="ÏßÄÏõê", value="ÏßÄÏõê"), app_commands.Choice(name="ÎØ∏ÏßÄÏõê", value="ÎØ∏ÏßÄÏõê")],
        Î¨∏ÏÉÅÍ≤∞Ï†ú=[app_commands.Choice(name="ÏßÄÏõê", value="ÏßÄÏõê"), app_commands.Choice(name="ÎØ∏ÏßÄÏõê", value="ÎØ∏ÏßÄÏõê")]
    )
    async def Í≤∞Ï†úÏàòÎã®_ÏÑ§Ï†ï(self, it: discord.Interaction, Í≥ÑÏ¢åÏù¥Ï≤¥: app_commands.Choice[str], ÏΩîÏù∏Í≤∞Ï†ú: app_commands.Choice[str], Î¨∏ÏÉÅÍ≤∞Ï†ú: app_commands.Choice[str]):
        DB["payments"]["bank"]    = (Í≥ÑÏ¢åÏù¥Ï≤¥.value == "ÏßÄÏõê")
        DB["payments"]["coin"]    = (ÏΩîÏù∏Í≤∞Ï†ú.value == "ÏßÄÏõê")
        DB["payments"]["culture"] = (Î¨∏ÏÉÅÍ≤∞Ï†ú.value == "ÏßÄÏõê")
        db_save()
        await it.response.send_message(embed=set_v2(discord.Embed(title="Í≤∞Ï†úÏàòÎã® ÏÑ§Ï†ï ÏôÑÎ£å", description=f"Í≥ÑÏ¢åÏù¥Ï≤¥: {Í≥ÑÏ¢åÏù¥Ï≤¥.value}\nÏΩîÏù∏Í≤∞Ï†ú: {ÏΩîÏù∏Í≤∞Ï†ú.value}\nÎ¨∏ÏÉÅÍ≤∞Ï†ú: {Î¨∏ÏÉÅÍ≤∞Ï†ú.value}", color=GRAY)), ephemeral=True)

    @app_commands.command(name="Í≥ÑÏ¢åÎ≤àÌò∏_ÏÑ§Ï†ï", description="Í≥ÑÏ¢åÏ†ïÎ≥¥ ÏÑ§Ï†ï")
    @app_commands.guilds(GUILD)
    @is_admin()
    async def Í≥ÑÏ¢åÎ≤àÌò∏_ÏÑ§Ï†ï(self, it: discord.Interaction):
        class Modal(discord.ui.Modal, title="Í≥ÑÏ¢åÎ≤àÌò∏ ÏÑ§Ï†ï"):
            bank_input   = discord.ui.TextInput(label="ÏùÄÌñâÎ™Ö", required=True, max_length=30)
            number_input = discord.ui.TextInput(label="Í≥ÑÏ¢åÎ≤àÌò∏", required=True, max_length=40)
            holder_input = discord.ui.TextInput(label="ÏòàÍ∏àÏ£º", required=True, max_length=30)
            def __init__(self, owner_id: int): super().__init__(); self.owner_id=owner_id
            async def on_submit(self, inter: discord.Interaction):
                if inter.user.id != self.owner_id:
                    await inter.response.send_message("ÏûëÏÑ±ÏûêÎßå Í∞ÄÎä•", ephemeral=True); return
                DB["account"]["bank"]=str(self.bank_input.value).strip()
                DB["account"]["number"]=str(self.number_input.value).strip()
                DB["account"]["holder"]=str(self.holder_input.value).strip()
                db_save()
                await inter.response.send_message(embed=set_v2(discord.Embed(title="Í≥ÑÏ¢åÏ†ïÎ≥¥ Ï†ÄÏû• ÏôÑÎ£å", description=f"ÏùÄÌñâÎ™Ö `{DB['account']['bank']}`\nÍ≥ÑÏ¢åÎ≤àÌò∏ `{DB['account']['number']}`\nÏòàÍ∏àÏ£º `{DB['account']['holder']}`", color=GRAY)), ephemeral=True)
        await it.response.send_modal(Modal(it.user.id))

    @app_commands.command(name="Ïú†Ï†Ä_ÏÑ§Ï†ï", description="Ïú†Ï†Ä Ï∞®Îã®/Ìï¥Ï†ú")
    @app_commands.guilds(GUILD)
    @is_admin()
    @app_commands.describe(Ïú†Ï†Ä="ÎåÄÏÉÅ Ïú†Ï†Ä", Ïó¨Î∂Ä="Ï∞®Îã®ÌïòÍ∏∞/Ï∞®Îã®ÌíÄÍ∏∞")
    @app_commands.choices(Ïó¨Î∂Ä=[app_commands.Choice(name="Ï∞®Îã®ÌïòÍ∏∞", value="ban"), app_commands.Choice(name="Ï∞®Îã®ÌíÄÍ∏∞", value="unban")])
    async def Ïú†Ï†Ä_ÏÑ§Ï†ï(self, it: discord.Interaction, Ïú†Ï†Ä: discord.Member, Ïó¨Î∂Ä: app_commands.Choice[str]):
        gid=str(it.guild.id); uid=str(Ïú†Ï†Ä.id)
        DB["bans"].setdefault(gid, {})
        if Ïó¨Î∂Ä.value == "ban":
            DB["bans"][gid][uid] = True; db_save()
            await it.channel.send(embed=set_v2(discord.Embed(title="Ï∞®Îã®ÌïòÍ∏∞", description=f"{Ïú†Ï†Ä}ÎãòÏùÄ ÏûêÌåêÍ∏∞ Ïù¥Ïö© Î∂àÍ∞ÄÎä•", color=RED)))
            await it.response.send_message("Ï≤òÎ¶¨ ÏôÑÎ£å", ephemeral=True)
        else:
            DB["bans"][gid].pop(uid, None); db_save()
            await it.channel.send(embed=set_v2(discord.Embed(title="Ï∞®Îã®ÌíÄÍ∏∞", description=f"{Ïú†Ï†Ä}ÎãòÏùÄ Îã§Ïãú Ïù¥Ïö© Í∞ÄÎä•", color=GREEN)))
            await it.response.send_message("Ï≤òÎ¶¨ ÏôÑÎ£å", ephemeral=True)

    @app_commands.command(name="Ïú†Ï†Ä_Ï°∞Ìöå", description="Ïú†Ï†Ä Ï°∞Ìöå")
    @app_commands.guilds(GUILD)
    @is_admin()
    async def Ïú†Ï†Ä_Ï°∞Ìöå(self, it: discord.Interaction, Ïú†Ï†Ä: discord.Member):
        gid=it.guild.id; uid=Ïú†Ï†Ä.id
        ords=orders_get(gid, uid); spent=0
        for o in ords:
            p=next((pp for pp in DB["products"] if pp["name"]==o["product"]), None)
            if p: spent += p["price"]*o["qty"]
        bal=bal_get(gid, uid); pts=DB["points"].get(str(gid), {}).get(str(uid), 0)
        await it.response.send_message(embed=set_v2(discord.Embed(title=f"{Ïú†Ï†Ä} Ï†ïÎ≥¥", description=f"Î≥¥Ïú† Í∏àÏï° : `{bal}`\nÎàÑÏ†Å Í∏àÏï° : `{spent}`\nÌè¨Ïù∏Ìä∏ : `{pts}`\nÍ±∞Îûò ÌöüÏàò : `{len(ords)}`", color=GRAY)), ephemeral=True)

    @app_commands.command(name="Ïª¨Ï≥êÎûúÎìú_ÏÑ§Ï†ï", description="Ïª¨Ï≥êÎûúÎìú Í≥ÑÏ†ï Îì±Î°ù/Í∞±Ïã†")
    @app_commands.guilds(GUILD)
    @is_admin()
    async def Ïª¨Ï≥êÎûúÎìú_ÏÑ§Ï†ï(self, it: discord.Interaction):
        await it.response.send_modal(CultureAccountModal(it.user.id))

# ===== FastAPI ÏõπÌõÖ(Ïπ¥Î±Ö) =====
app = FastAPI()

def parse_sms_kakaobank(msg: str) -> tuple[int | None, str | None]:
    RE_AMOUNT = [re.compile(r"ÏûÖÍ∏à\s*([0-9][0-9,]*)\s*Ïõê")]
    text = str(msg or ""); amount=None
    for r in RE_AMOUNT:
        m=r.search(text)
        if m:
            raw=m.group(1).replace(",","")
            if raw.isdigit(): amount=int(raw); break
    depositor=None
    lines=[ln.strip() for ln in text.splitlines() if ln.strip()]
    for i,l in enumerate(lines):
        if l.startswith("ÏûÖÍ∏à"):
            if i+1<len(lines): depositor=lines[i+1].split()[0]
            break
    if depositor and ("ÏûîÏï°" in depositor or depositor.startswith("ÏûîÏï°")): depositor=None
    return amount,depositor

def parse_sms_any(msg: str) -> tuple[int | None, str | None]:
    amount=None; m=re.search(r"([0-9][0-9,]*)\s*Ïõê", msg or "")
    if m:
        raw=m.group(1).replace(",","")
        if raw.isdigit(): amount=int(raw)
    depositor=None
    for r in [re.compile(r"ÏûÖÍ∏à\s+[0-9,]+\s*Ïõê\s+([^\s\|]+)"),
              re.compile(r"ÏûÖÍ∏àÏûê\s*[:\-]?\s*([^\s\|]+)"),
              re.compile(r"(Î≥¥ÎÇ∏Î∂Ñ|Î≥¥ÎÇ∏Ïù¥)\s*[:\-]?\s*([^\s\|]+)"),
              re.compile(r"\n([^\n\|]+)\s*(ÏûîÏï°|Ïõê|ÏûÖÍ∏à|$)")]:
        m=r.search(msg or "")
        if m:
            depositor=(m.group(2) if (m.lastindex and m.lastindex>=2) else m.group(1)).strip(); break
    return amount,depositor

def parse_sms(msg: str) -> tuple[int | None, str | None]:
    a,d = parse_sms_kakaobank(msg)
    if a is None or d is None:
        a2,d2 = parse_sms_any(msg)
        if a is None: a=a2
        if d is None: d=d2
    return a,d

@app.post("/kbank-webhook")
async def kbank_webhook(req: Request):
    try:
        token=(req.headers.get("Authorization") or "").replace("Bearer","").strip()
        if token!=WEBHOOK_SECRET:
            return {"ok": False, "error":"unauthorized"}
        body=await req.json()
        gid=int(body.get("guildId") or body.get("server_id") or 0)
        msg=body.get("msg"); amount=body.get("amount"); depositor=body.get("depositor")
        if (amount is None or depositor is None) and isinstance(msg, str):
            a,d=parse_sms(msg); 
            if amount is None: amount=a
            if depositor is None: depositor=d
        if not gid: return {"ok": False, "error":"guild_required"}
        g=bot.get_guild(gid)
        if not g: return {"ok": False, "error":"guild_not_found"}
        if amount is None or depositor is None:
            await send_log_text(g, "admin", "[ÏûêÎèôÏ∂©Ï†Ñ] ÌååÏã± Ïã§Ìå®")
            return {"ok": False, "result":"parse_failed"}
        ok,res=await handle_deposit(g, int(amount), str(depositor))
        return {"ok": ok, "result": res}
    except Exception as e:
        return {"ok": False, "error": str(e)}

def run_api():
    uvicorn.run(app, host="0.0.0.0", port=int(os.getenv("PORT","8787")), log_level="warning")

# ===== Î∂ÄÌä∏ =====
async def guild_sync(b: commands.Bot):
    try:
        await b.tree.sync(guild=GUILD)
        print("[setup_hook] Í∏∏Îìú Ïã±ÌÅ¨ ÏôÑÎ£å")
    except Exception as e:
        print(f"[setup_hook] Í∏∏Îìú Ïã±ÌÅ¨ Ïã§Ìå®: {e}")

@bot.event
async def setup_hook():
    await bot.add_cog(ControlCog(bot))
    await guild_sync(bot)

@bot.event
async def on_ready():
    print(f"Î°úÍ∑∏Ïù∏: {bot.user} (Ï§ÄÎπÑ ÏôÑÎ£å)")
    t=threading.Thread(target=run_api, daemon=True); t.start()

TOKEN=os.getenv("DISCORD_TOKEN","Ïó¨Í∏∞Ïóê_ÌÜ†ÌÅ∞_ÎÑ£Í∏∞")
bot.run(TOKEN)
