import os, json, time, re, statistics, threading, hashlib, asyncio
import discord
from discord import app_commands
from discord.ext import commands
from fastapi import FastAPI, Request
import uvicorn

# ===== ÌôòÍ≤Ω =====
GUILD_ID = int(os.getenv("GUILD_ID", "1419200424636055592"))
GUILD = discord.Object(id=GUILD_ID)

GRAY = discord.Color.from_str("#808080")
RED = discord.Color.red()
GREEN = discord.Color.green()
ORANGE = discord.Color.orange()
PINK = discord.Color.from_str("#ff5ea3")

# Ïª§Ïä§ÌÖÄ/Ïï†Îãà Ïù¥Î™®ÏßÄ RAW
EMOJI_NOTICE = "<:Announcement:1422906665249800274>"
EMOJI_CHARGE = "<a:11845034938353746621:1421383445669613660>"
EMOJI_INFO   = "<:info:1422579514218905731>"
EMOJI_BUY    = "<a:ShoppingCart:1325375304356597852>"
EMOJI_TOSS   = "<:TOSS:1421430302684745748>"
EMOJI_COIN   = "<:emoji_68:1421430304706658347>"
EMOJI_CULTURE= "<:culture:1421430797604229150>"
EMOJI_TICKET = "<:ticket:1389546740054626304>"
EMOJI_HEART  = "üíå"
EMOJI_APPROVE= "<a:1209511710545813526:1421430914373779618>"
EMOJI_DECLINE= "<a:1257004507125121105:1421430917049749506>"

intents = discord.Intents.default()
intents.members = True
bot = commands.Bot(command_prefix="!", intents=intents)

# ===== DB =====
DB_PATH = "data.json"
WEBHOOK_SECRET = os.getenv("WEBHOOK_SECRET", "KBRIDGE_9f8a1c2b0e4a4a7f")
_db_lock = threading.Lock()

def _default_db():
    return {
        "categories": [],                       # [{name, desc, emoji_raw}]
        "products": [],                         # [{name, category, price, stock, items[], emoji_raw, ratings[], sold_count, desc}]
        "logs": {
            "purchase": {"enabled": False, "target_channel_id": None},
            "review":   {"enabled": False, "target_channel_id": None},
            "admin":    {"enabled": False, "target_channel_id": None},
            "secure":   {"enabled": False, "target_channel_id": None}  # Î≥¥ÏïàÏ±ÑÎÑê(Ï∂©Ï†Ñ ÏäπÏù∏/Í±∞Î∂Ä)
        },
        "payments": {"bank": False, "coin": False, "culture": False},
        "balances": {},                         # {guild:{user: int}}
        "points": {},                           # {guild:{user: int}}
        "orders": {},                           # {guild:{user:[{product, qty, ts}]}}
        "account": {"bank": "", "number": "", "holder": ""},
        "bans": {},                             # {guild:{user: bool}}
        "reviews": {},
        "purchases_sent": {},                   # ÌõÑÍ∏∞ 1Ìöå Ï†úÌïúÏö© {gid:{uid:{uniqueKey:True}}}
        "topups": {"requests": [], "receipts": []}
    }

def db_load():
    if not os.path.exists(DB_PATH):
        return _default_db()
    try:
        with open(DB_PATH, "r", encoding="utf-8") as f:
            data = json.load(f)
    except Exception:
        return _default_db()
    base=_default_db()
    for k,v in base.items():
        data.setdefault(k,v)
    def _intmap(d):
        out={}
        if isinstance(d, dict):
            for k,v in d.items():
                try: out[str(k)] = int(v)
                except: out[str(k)] = 0
        return out
    data["balances"] = {str(g): _intmap(u) for g,u in data.get("balances",{}).items()}
    data["points"]   = {str(g): _intmap(u) for g,u in data.get("points",{}).items()}
    for k in ("bank","number","holder"):
        data["account"][k] = str(data["account"].get(k,""))
    data["topups"].setdefault("requests", [])
    data["topups"].setdefault("receipts", [])
    data["purchases_sent"] = {**data.get("purchases_sent", {})}
    return data

def db_save():
    with _db_lock:
        with open(DB_PATH, "w", encoding="utf-8") as f:
            json.dump(DB, f, ensure_ascii=False, indent=2)

DB = db_load()

# ===== Ïú†Ìã∏ =====
CUSTOM_EMOJI_RE = re.compile(r'^<(?P<anim>a?):(?P<name>[A-Za-z0-9_]+):(?P<id>\d+)>$')
def parse_partial_emoji(text: str):
    if not text: return None
    m = CUSTOM_EMOJI_RE.match(text.strip())
    if not m: return None
    try:
        return discord.PartialEmoji(name=m.group("name"), id=int(m.group("id")), animated=(m.group("anim")=="a"))
    except:
        return None

def safe_emoji(raw: str | None):
    pe = parse_partial_emoji(raw or "")
    return pe if pe else None

def _now(): return int(time.time())

def star_bar(avg: float | None) -> str:
    if avg is None: return "ÌèâÏ†ê ÏóÜÏùå"
    n = max(1, min(int(round(avg)), 5))
    return "‚≠êÔ∏è"*n

def product_avg_stars(p: dict) -> str:
    ratings = p.get("ratings", [])
    avg = round(statistics.mean(ratings), 1) if ratings else None
    return star_bar(avg)

def category_avg_stars(cat_name: str) -> str:
    ps = [p for p in DB["products"] if p["category"]==cat_name and p.get("ratings")]
    if not ps: return "ÌèâÏ†ê ÏóÜÏùå"
    all_r=[]
    for p in ps: all_r += p.get("ratings", [])
    if not all_r: return "ÌèâÏ†ê ÏóÜÏùå"
    avg = round(statistics.mean(all_r), 1)
    return star_bar(avg)

def ban_is_blocked(gid: int, uid: int) -> bool:
    return bool(DB["bans"].get(str(gid), {}).get(str(uid), False))

def bal_get(gid: int, uid: int) -> int:
    return DB["balances"].get(str(gid), {}).get(str(uid), 0)

def bal_set(gid: int, uid: int, val: int):
    DB["balances"].setdefault(str(gid), {})
    DB["balances"][str(gid)][str(uid)] = int(val); db_save()

def bal_add(gid: int, uid: int, amt: int):
    bal_set(gid, uid, bal_get(gid, uid) + max(0, int(amt)))

def bal_sub(gid: int, uid: int, amt: int):
    bal_set(gid, uid, bal_get(gid, uid) - max(0, int(amt)))

def pt_get(gid: int, uid: int) -> int:
    return DB["points"].get(str(gid), {}).get(str(uid), 0)

def pt_set(gid: int, uid: int, val: int):
    DB["points"].setdefault(str(gid), {})
    DB["points"][str(gid)][str(uid)] = int(val); db_save()

def orders_get(gid: int, uid: int):
    return DB.get("orders", {}).get(str(gid), {}).get(str(uid), [])

def orders_add(gid: int, uid: int, product: str, qty: int):
    DB.setdefault("orders", {}).setdefault(str(gid), {}).setdefault(str(uid), []).append(
        {"product": product, "qty": int(qty), "ts": _now()}
    ); db_save()

def prod_get(name: str, category: str):
    return next((p for p in DB["products"] if p["name"]==name and p["category"]==category), None)

def prod_list_by_cat(category: str):
    return [p for p in DB["products"] if p["category"]==category]

def prod_list_all():
    return list(DB["products"])

def prod_upsert(name: str, category: str, price: int, emoji_raw: str = "", desc: str = ""):
    p = prod_get(name, category)
    if p:
        p.update({"price": int(max(0, price)), "emoji_raw": emoji_raw, "desc": desc})
    else:
        DB["products"].append({
            "name": name, "category": category, "price": int(max(0, price)),
            "stock": 0, "items": [], "emoji_raw": emoji_raw, "ratings": [],
            "sold_count": 0, "desc": desc
        })
    db_save()

def prod_delete(name: str, category: str):
    DB["products"] = [p for p in DB["products"] if not (p["name"]==name and p["category"]==category)]
    db_save()

def set_v2(e: discord.Embed):
    try: e.set_author(name="")
    except: pass
    try: e.set_footer(text="")
    except: pass
    return e

# ===== Î°úÍ∑∏ Ï±ÑÎÑê =====
def get_log_channel(guild: discord.Guild, key: str) -> discord.TextChannel | None:
    cfg = DB["logs"].get(key) or {}
    if not cfg.get("enabled") or not cfg.get("target_channel_id"): return None
    ch = guild.get_channel(int(cfg["target_channel_id"]))
    return ch if isinstance(ch, discord.TextChannel) else None

async def send_log_embed(guild: discord.Guild, key: str, embed: discord.Embed):
    ch = get_log_channel(guild, key)
    if not ch: return False
    try:
        await ch.send(embed=embed); return True
    except: return False

# ===== Íµ¨Îß§Î°úÍ∑∏/ÌõÑÍ∏∞/DM ÏûÑÎ≤†Îìú =====
def emb_purchase_log(user: discord.User, product: str, qty: int):
    e = discord.Embed(title="Íµ¨Îß§Î°úÍ∑∏",
                      description=f"{user.mention}Îãò {product} {qty}Í∞ú\nÍµ¨Îß§ Í∞êÏÇ¨Ìï©ÎãàÎã§ ÌõÑÍ∏∞ ÏûëÏÑ± Î∂ÄÌÉÅÎìúÎ¶ΩÎãàÎã§:gift_heart:",
                      color=GRAY)
    return set_v2(e)

def emb_review_full(product: str, stars: int, content: str):
    stars = max(1, min(stars, 5))
    stars_text = "‚≠êÔ∏è" * stars
    line = "„Ö°"*18
    e = discord.Embed(title="Íµ¨Îß§ ÌõÑÍ∏∞",
                      description=f"**Íµ¨Îß§Ï†úÌíà** : {product}\n**Î≥ÑÏ†ê** : {stars_text}\n{line}\n{content}\n{line}",
                      color=GRAY)
    return set_v2(e)

def emb_purchase_dm(product: str, qty: int, price: int, items: list[str]):
    line = "„Ö°"*18
    visible = items[:20]
    rest = len(items) - len(visible)
    block = "\n".join(visible) + (f"\nÏô∏ {rest}Í∞ú‚Ä¶" if rest>0 else "")
    if not block: block = "ÌëúÏãúÌï† Ìï≠Î™©Ïù¥ ÏóÜÏäµÎãàÎã§"
    e = discord.Embed(title="Íµ¨Îß§ ÏÑ±Í≥µ",
                      description=f"Ï†úÌíà Ïù¥Î¶Ñ : {product}\nÍµ¨Îß§ Í∞úÏàò : {qty}\nÏ∞®Í∞ê Í∏àÏï° : {price}\n{line}\n{block}",
                      color=GREEN)
    return set_v2(e)

# ===== ÏûêÎèôÏ∂©Ï†Ñ(Ïπ¥Î±Ö ÌååÏÑú/Îß§Ïπ≠) =====
TOPUP_TIMEOUT_SEC = 5*60
RE_AMOUNT = [re.compile(r"ÏûÖÍ∏à\s*([0-9][0-9,]*)\s*Ïõê")]

def parse_sms_kakaobank(msg: str) -> tuple[int | None, str | None]:
    text = str(msg or "")
    amount=None
    for r in RE_AMOUNT:
        m=r.search(text)
        if m:
            raw=m.group(1).replace(",","")
            if raw.isdigit(): amount=int(raw); break
    depositor=None
    lines=[ln.strip() for ln in text.splitlines() if ln.strip()]
    for i,l in enumerate(lines):
        if l.startswith("ÏûÖÍ∏à"):
            if i+1<len(lines): depositor = lines[i+1].split()[0]
            break
    if depositor and ("ÏûîÏï°" in depositor or depositor.startswith("ÏûîÏï°")):
        depositor=None
    return amount, depositor

RE_DEPOSITOR_FALLBACK = [
    re.compile(r"ÏûÖÍ∏à\s+[0-9,]+\s*Ïõê\s+([^\s\|]+)"),
    re.compile(r"ÏûÖÍ∏àÏûê\s*[:\-]?\s*([^\s\|]+)"),
    re.compile(r"(Î≥¥ÎÇ∏Î∂Ñ|Î≥¥ÎÇ∏Ïù¥)\s*[:\-]?\s*([^\‡§∏\|]+)"),
    re.compile(r"\n([^\n\|]+)\s*(ÏûîÏï°|Ïõê|ÏûÖÍ∏à|$)")
]

def parse_sms_any(msg: str) -> tuple[int | None, str | None]:
    amount=None
    m=re.search(r"([0-9][0-9,]*)\s*Ïõê", msg or "")
    if m:
        raw=m.group(1).replace(",","")
        if raw.isdigit(): amount=int(raw)
    depositor=None
    for r in RE_DEPOSITOR_FALLBACK:
        m=r.search(msg or "")
        if m:
            name=m.group(2) if (m.lastindex and m.lastindex>=2) else m.group(1)
            depositor=str(name).strip()
            break
    return amount, depositor

def parse_sms(msg: str) -> tuple[int | None, str | None]:
    a,d = parse_sms_kakaobank(msg)
    if a is None or d is None:
        a2,d2 = parse_sms_any(msg)
        if a is None: a=a2
        if d is None: d=d2
    return a,d

def expire_old_requests():
    now=_now()
    changed=False
    for r in DB["topups"]["requests"]:
        if r.get("status","pending")=="pending" and now - int(r.get("ts",now)) > TOPUP_TIMEOUT_SEC:
            r["status"]="expired"; changed=True
    if changed: db_save()

def _hash_receipt(gid:int, amount:int, depositor:str):
    bucket=_now()//10
    base=f"{gid}|{amount}|{str(depositor).lower()}|{bucket}"
    return hashlib.sha256(base.encode("utf-8")).hexdigest()[:24]

async def handle_deposit(guild: discord.Guild, amount: int, depositor: str):
    expire_old_requests()
    key=_hash_receipt(guild.id, int(amount), str(depositor))
    if any(rc.get("hash")==key for rc in DB["topups"]["receipts"]):
        return False, "duplicate"
    now=_now()
    pending=[r for r in DB["topups"]["requests"]
             if r.get("status","pending")=="pending"
             and r.get("guildId")==guild.id
             and now - int(r.get("ts",now)) <= TOPUP_TIMEOUT_SEC
             and int(r.get("amount",0))==int(amount)]
    exact=[r for r in pending if str(r.get("depositor","")).strip().lower()==str(depositor).strip().lower()]
    exact.sort(key=lambda r:int(r.get("ts",0)), reverse=True)
    pending.sort(key=lambda r:int(r.get("ts",0)), reverse=True)
    target = exact[0] if exact else (pending[0] if pending else None)
    matched_user_id=None
    if target:
        matched_user_id=int(target["userId"])
        target["status"]="ok"
        bal_add(guild.id, matched_user_id, int(amount))
        db_save()
        try:
            user=guild.get_member(matched_user_id) or await guild.fetch_member(matched_user_id)
            dm=await user.create_dm()
            await dm.send(f"[ÏûêÎèôÏ∂©Ï†Ñ ÏôÑÎ£å]\nÍ∏àÏï°: {amount}Ïõê\nÏûÖÍ∏àÏûê: {depositor}")
        except: pass
    DB["topups"]["receipts"].append({
        "hash":key,"guildId":guild.id,"amount":int(amount),
        "depositor":str(depositor),"ts":_now(),"userId":matched_user_id
    }); db_save()
    return (True,"matched") if matched_user_id else (False,"queued")

# ===== ÌõÑÍ∏∞(ÌïëÌÅ¨ Î≤ÑÌäº + 1Ìöå Ï†úÌïú + Ï±ÑÎÑê Ï†ÑÏÜ°) =====
def can_send_review(gid:int, uid:int, unique_key:str) -> bool:
    DB["purchases_sent"].setdefault(str(gid), {}).setdefault(str(uid), {})
    return not DB["purchases_sent"][str(gid)][str(uid)].get(unique_key, False)

def lock_review(gid:int, uid:int, unique_key:str):
    DB["purchases_sent"].setdefault(str(gid), {}).setdefault(str(uid), {})
    DB["purchases_sent"][str(gid)][str(uid)][unique_key]=True
    db_save()

class ReviewSendModal(discord.ui.Modal, title="Íµ¨Îß§ ÌõÑÍ∏∞ ÏûëÏÑ±"):
    product_input = discord.ui.TextInput(label="Íµ¨Îß§ Ï†úÌíà", required=True, max_length=60)
    stars_input   = discord.ui.TextInput(label="Î≥ÑÏ†ê(1~5)", required=True, max_length=1)
    content_input = discord.ui.TextInput(label="ÌõÑÍ∏∞ ÎÇ¥Ïö©", style=discord.TextStyle.paragraph, required=True, max_length=500)
    def __init__(self, gid:int, uid:int, unique_key:str, default_product:str=""):
        super().__init__()
        self.gid=gid; self.uid=uid; self.unique_key=unique_key
        if default_product: self.product_input.default=default_product
    async def on_submit(self, it: discord.Interaction):
        if not can_send_review(self.gid, self.uid, self.unique_key):
            await it.response.send_message(embed=set_v2(discord.Embed(
                title="ÌõÑÍ∏∞ Ï†ÑÏÜ° Î∂àÍ∞Ä", description="Ïù¥ Íµ¨Îß§Í±¥ÏùÄ Ïù¥ÎØ∏ ÌõÑÍ∏∞Î•º ÏûëÏÑ±ÌñàÏäµÎãàÎã§.", color=PINK
            )), ephemeral=True); return
        s=str(self.stars_input.value).strip()
        if not s.isdigit() or not (1<=int(s)<=5):
            await it.response.send_message("Î≥ÑÏ†êÏùÄ 1~5 Ïà´ÏûêÎ°ú ÏûÖÎ†•Ìï¥Ï§ò.", ephemeral=True); return
        product=str(self.product_input.value).strip()
        content=str(self.content_input.value).strip()
        e = emb_review_full(product, int(s), content)
        guild = it.guild or bot.get_guild(GUILD_ID)
        if guild:
            ch = get_log_channel(guild, "review")
            if ch: await ch.send(embed=e)
        lock_review(self.gid, self.uid, self.unique_key)
        await it.response.send_message("ÌõÑÍ∏∞ Ï†ÑÏÜ° ÏôÑÎ£å!", ephemeral=True)

class ReviewButtonView(discord.ui.View):
    def __init__(self, gid:int, uid:int, unique_key:str, default_product:str=""):
        super().__init__(timeout=None)
        btn = discord.ui.Button(label=f"{EMOJI_HEART} ÌõÑÍ∏∞ Ï†ÑÏÜ°", style=discord.ButtonStyle.secondary)
        async def _cb(i:discord.Interaction):
            if i.user.id!=uid:
                await i.response.send_message("Íµ¨Îß§ÏûêÎßå ÏûëÏÑ±Ìï† Ïàò ÏûàÏñ¥.", ephemeral=True); return
            if not can_send_review(gid, uid, unique_key):
                await i.response.send_message("Ïù¥ÎØ∏ Ïù¥ Íµ¨Îß§Í±¥ÏúºÎ°ú ÌõÑÍ∏∞Î•º ÏûëÏÑ±ÌñàÏñ¥.", ephemeral=True); return
            await i.response.send_modal(ReviewSendModal(gid, uid, unique_key, default_product))
        btn.callback=_cb
        self.add_item(btn)

# ===== Ï∂©Ï†Ñ(Ïú†Ï†Ä ÏûÑÎ≤†Îìú: ephemeral / Î≥¥ÏïàÏ±ÑÎÑê ÏäπÏù∏/Í±∞Î∂Ä) =====
class SecureApproveView(discord.ui.View):
    def __init__(self, payload: dict):
        super().__init__(timeout=TOPUP_TIMEOUT_SEC)
        b_ok=discord.ui.Button(label="ÏäπÏù∏", style=discord.ButtonStyle.success, emoji=safe_emoji(EMOJI_APPROVE))
        b_no=discord.ui.Button(label="Í±∞Î∂Ä", style=discord.ButtonStyle.danger,  emoji=safe_emoji(EMOJI_DECLINE))
        async def _ok(i:discord.Interaction):
            await notify_user_topup_result(i.client, payload, approved=True)
            await i.response.edit_message(embed=set_v2(discord.Embed(
                title="ÏäπÏù∏ ÏôÑÎ£å", description="Ìï¥Îãπ Ï∂©Ï†ÑÏã†Ï≤≠ÏùÑ ÏäπÏù∏ÌñàÏäµÎãàÎã§.", color=GREEN
            )), view=None)
        async def _no(i:discord.Interaction):
            await notify_user_topup_result(i.client, payload, approved=False)
            await i.response.edit_message(embed=set_v2(discord.Embed(
                title="Í±∞Î∂Ä ÏôÑÎ£å", description="Ìï¥Îãπ Ï∂©Ï†ÑÏã†Ï≤≠ÏùÑ Í±∞Î∂ÄÌñàÏäµÎãàÎã§.", color=RED
            )), view=None)
        b_ok.callback=_ok; b_no.callback=_no
        self.add_item(b_ok); self.add_item(b_no)

async def notify_user_topup_result(client: discord.Client, payload: dict, approved: bool):
    gid=int(payload["guild_id"]); uid=int(payload["user_id"])
    guild = client.get_guild(gid)
    if not guild: return
    try:
        user = guild.get_member(uid) or await guild.fetch_member(uid)
        e=set_v2(discord.Embed(
            title=("Ï∂©Ï†ÑÏôÑÎ£å" if approved else "Ï∂©Ï†ÑÏã§Ìå®"),
            description=("Ï∂©Ï†ÑÏã†Ï≤≠Ïù¥ ÏÑ±Í≥µÏ†ÅÏúºÎ°ú ÏôÑÎ£åÎêòÏóàÏäµÎãàÎã§" if approved else "Ï∂©Ï†ÑÏã†Ï≤≠Ïù¥ Í±∞Î∂ÄÎêòÏóàÏäµÎãàÎã§"),
            color=(GREEN if approved else RED)
        ))
        dm=await user.create_dm()
        await dm.send(embed=e)
    except: pass

class PaymentModal(discord.ui.Modal, title="Ï∂©Ï†Ñ Ïã†Ï≤≠"):
    amount_input = discord.ui.TextInput(label="Ï∂©Ï†ÑÌï† Í∏àÏï°", required=True, max_length=12)
    depositor_input = discord.ui.TextInput(label="ÏûÖÍ∏àÏûêÎ™Ö", required=True, max_length=20)
    def __init__(self, owner_id:int):
        super().__init__(); self.owner_id=owner_id
    async def on_submit(self, it: discord.Interaction):
        try:
            amt_raw=str(self.amount_input.value).strip().replace(",","")
            amt=int(amt_raw) if amt_raw.isdigit() else 0
            depos=str(self.depositor_input.value).strip()
            if amt>0 and depos:
                DB["topups"]["requests"].append({
                    "guildId": it.guild.id, "userId": it.user.id,
                    "amount": amt, "depositor": depos, "ts": _now(), "status": "pending"
                }); db_save()
        except: pass
        bank=DB["account"].get("bank","ÎØ∏Îì±Î°ù")
        holder=DB["account"].get("holder","ÎØ∏Îì±Î°ù")
        number=DB["account"].get("number","ÎØ∏Îì±Î°ù")
        amount_txt=f"{amt_raw}Ïõê" if amt_raw else "0Ïõê"

        # Ïú†Ï†Ä ÏïàÎÇ¥(ÏóêÌéòÎ©îÎûÑ, ÏïàÎÇ¥ Î¨∏Íµ¨ ÏÇ≠Ï†ú)
        e_user=set_v2(discord.Embed(
            title="Ï∂©Ï†ÑÏã†Ï≤≠",
            description=f"ÏùÄÌñâÎ™Ö : {bank}\nÏòàÍ∏àÏ£º : {holder}\nÍ≥ÑÏ¢åÎ≤àÌò∏ : `{number}`\nÎ≥¥ÎÇ¥ÏïºÌï† Í∏àÏï° : {amount_txt}",
            color=GREEN
        ))
        await it.response.send_message(embed=e_user, ephemeral=True)

        # Î≥¥ÏïàÏ±ÑÎÑê ÏïåÎ¶º + ÏäπÏù∏/Í±∞Î∂Ä
        secure_ch=get_log_channel(it.guild, "secure")
        if secure_ch:
            payload={"guild_id":it.guild.id,"user_id":it.user.id,"amount":amt,"amount_txt":amount_txt,"depositor":depos}
            e_sec=set_v2(discord.Embed(
                title="Ï∂©Ï†ÑÏïåÎ¶º",
                description=f"Ïú†Ï†Ä : {it.user.mention}\nÏ∂©Ï†Ñ Í∏àÏï° : {amount_txt}\nÏûÖÍ∏àÏûêÎ™Ö : {depos}",
                color=ORANGE
            ))
            await secure_ch.send(embed=e_sec, view=SecureApproveView(payload))

class PaymentMethodView(discord.ui.View):
    def __init__(self):
        super().__init__(timeout=None)
        items=[]
        if DB["payments"].get("bank", False):
            items.append(discord.ui.Button(label="Í≥ÑÏ¢åÏù¥Ï≤¥", style=discord.ButtonStyle.secondary, emoji=safe_emoji(EMOJI_TOSS)))
        if DB["payments"].get("coin", False):
            items.append(discord.ui.Button(label="ÏΩîÏù∏Ï∂©Ï†Ñ", style=discord.ButtonStyle.secondary, emoji=safe_emoji(EMOJI_COIN)))
        if DB["payments"].get("culture", False):
            items.append(discord.ui.Button(label="Î¨∏ÏÉÅÏ∂©Ï†Ñ", style=discord.ButtonStyle.secondary, emoji=safe_emoji(EMOJI_CULTURE)))
        for b in items:
            async def _cb(i:discord.Interaction, label=b.label):
                if label=="Í≥ÑÏ¢åÏù¥Ï≤¥":
                    await i.response.send_modal(PaymentModal(i.user.id))
                else:
                    await i.response.send_message(embed=set_v2(discord.Embed(
                        title="Ïã§Ìå®", description="ÌòÑÏû¨ ÎØ∏ÏßÄÏõê", color=RED
                    )), ephemeral=True)
            b.callback=_cb
            self.add_item(b)

# ===== Ïπ¥ÌÖåÍ≥†Î¶¨/Ï†úÌíà ÏûÑÎ≤†Îìú(ÏöîÏ≤≠ Ìè¨Îß∑ + Í∞ôÏùÄ Î©îÏãúÏßÄ ‚ÄòÏàòÏ†ï‚Äô ÌùêÎ¶Ñ) =====
def build_category_embed():
    lines=[]
    if DB["categories"]:
        for c in DB["categories"]:
            prod_count = len([p for p in DB["products"] if p["category"]==c["name"]])
            stars=category_avg_stars(c["name"])
            lines.append(f"**Ïπ¥ÌÖåÍ≥†Î¶¨Î™Ö : {c['name']}**")
            lines.append(f"-# Ï†úÌíà : {prod_count}")
            lines.append(f"-# Î≥ÑÏ†ê : {stars}")
            lines.append("„Ö°„Ö°„Ö°„Ö°„Ö°„Ö°„Ö°„Ö°„Ö°„Ö°„Ö°„Ö°„Ö°„Ö°„Ö°„Ö°")
    else:
        lines.append("Îì±Î°ùÎêú Ïπ¥ÌÖåÍ≥†Î¶¨Í∞Ä ÏóÜÏäµÎãàÎã§")
    return set_v2(discord.Embed(title="Ïπ¥ÌÖåÍ≥†Î¶¨Î•º ÏÑ†ÌÉùÌï¥Ï£ºÏÑ∏Ïöî", description="\n".join(lines), color=GRAY))

def build_product_embed(category_name:str):
    ps=[p for p in DB["products"] if p["category"]==category_name]
    lines=[]
    if ps:
        for p in ps:
            lines.append(f"**Ï†úÌíàÎ™Ö : {p['name']}**")
            lines.append(f"-# ÎÇ®ÏùÄ Ïû¨Í≥† : {p.get('stock',0)}")
            lines.append(f"-# Í∞ÄÍ≤© : __{p.get('price',0)}__")
            lines.append(f"-# Î≥ÑÏ†ê : {product_avg_stars(p)}")
            lines.append("„Ö°„Ö°„Ö°„Ö°„Ö°„Ö°„Ö°„Ö°„Ö°„Ö°„Ö°„Ö°„Ö°„Ö°„Ö°„Ö°")
    else:
        lines.append("Ìï¥Îãπ Ïπ¥ÌÖåÍ≥†Î¶¨Ïóê Ï†úÌíàÏù¥ ÏóÜÏäµÎãàÎã§")
    return set_v2(discord.Embed(title="Ï†úÌíà ÏÑ†ÌÉùÌïòÍ∏∞", description="Ï†úÌíàÏùÑ ÏÑ†ÌÉùÌï¥Ï£ºÏÑ∏Ïöî\n\n" + "\n".join(lines), color=GRAY))

# Î©îÏãúÏßÄ ÏàòÏ†ï ÌùêÎ¶ÑÏùÑ ÏúÑÌïú Ï†ÄÏû•ÏÜå: {guildId:{userId:{message_id:int, phase:str, category:str}}}
FLOW = {}

async def remember_flow_message(it: discord.Interaction, phase: str, category: str | None = None):
    FLOW.setdefault(str(it.guild.id), {})[str(it.user.id)] = {
        "message_id": (await it.original_response()).id,
        "phase": phase,
        "category": category or ""
    }

async def edit_flow_message(it: discord.Interaction, embed: discord.Embed, view: discord.ui.View | None):
    entry = FLOW.get(str(it.guild.id), {}).get(str(it.user.id))
    if not entry:
        await it.followup.send(embed=embed, view=view, ephemeral=True); return
    try:
        msg = await it.channel.fetch_message(entry["message_id"])
        await msg.edit(embed=embed, view=view)
    except:
        await it.followup.send(embed=embed, view=view, ephemeral=True)

class QuantityModal(discord.ui.Modal, title="ÏàòÎüâ ÏûÖÎ†•"):
    qty_input = discord.ui.TextInput(label="Íµ¨Îß§ ÏàòÎüâ", required=True, max_length=6)
    def __init__(self, owner_id:int, category:str, product_name:str):
        super().__init__(); self.owner_id=owner_id; self.category=category; self.product_name=product_name
    async def on_submit(self, it: discord.Interaction):
        if it.user.id!=self.owner_id:
            await it.response.send_message("ÏûëÏÑ±ÏûêÎßå Ï†úÏ∂úÌï† Ïàò ÏûàÏñ¥.", ephemeral=True); return
        s=str(self.qty_input.value).strip()
        if not s.isdigit() or int(s)<=0:
            await it.response.send_message("ÏàòÎüâÏùÄ 1 Ïù¥ÏÉÅÏùò Ïà´ÏûêÏó¨Ïïº Ìï¥.", ephemeral=True); return
        qty=int(s); p=prod_get(self.product_name, self.category)
        if not p:
            await it.response.send_message("Ïú†Ìö®ÌïòÏßÄ ÏïäÏùÄ Ï†úÌíàÏûÖÎãàÎã§.", ephemeral=True); return
        if p["stock"]<qty:
            await it.response.send_message(embed=set_v2(discord.Embed(
                title="Ïû¨Í≥† Î∂ÄÏ°±", description=f"{self.product_name} Ïû¨Í≥†Í∞Ä Î∂ÄÏ°±Ìï©ÎãàÎã§.", color=ORANGE
            )), ephemeral=True); return
        taken=[]; cnt=qty
        while cnt>0 and p["items"]:
            taken.append(p["items"].pop(0)); cnt-=1
        p["stock"]-=qty; p["sold_count"]+=qty; db_save()
        bal_sub(it.guild.id, it.user.id, p["price"]*qty)
        # DM + ÌõÑÍ∏∞ Î≤ÑÌäº
        try:
            dm=await it.user.create_dm()
            unique_key=f"{it.guild.id}:{it.user.id}:{self.product_name}:{_now()}"
            await dm.send(embed=emb_purchase_dm(self.product_name, qty, p["price"], taken),
                          view=ReviewButtonView(it.guild.id, it.user.id, unique_key, self.product_name))
        except: pass
        # Íµ¨Îß§Î°úÍ∑∏
        try:
            await send_log_embed(it.guild, "purchase", emb_purchase_log(it.user, self.product_name, qty))
        except: pass
        # Í∞ôÏùÄ Î©îÏãúÏßÄÎ•º 'Íµ¨Îß§ ÏôÑÎ£å'Î°ú ÏàòÏ†ï
        e_done=set_v2(discord.Embed(title="Íµ¨Îß§ ÏôÑÎ£å", description=f"{self.product_name} Íµ¨Îß§Í∞Ä ÏôÑÎ£åÎêòÏóàÏäµÎãàÎã§. DMÏùÑ ÌôïÏù∏Ìï¥Ï£ºÏÑ∏Ïöî.", color=GREEN))
        await it.response.defer(ephemeral=True)  # Î™®Îã¨ ÏùëÎãµ ÏÜåÍ±∞
        await edit_flow_message(it, e_done, view=None)

class ProductSelectClean(discord.ui.Select):
    def __init__(self, owner_id:int, category:str):
        ps=[p for p in DB["products"] if p["category"]==category]
        opts=[]
        if ps:
            for p in ps[:25]:
                opts.append(discord.SelectOption(label=p["name"], description=f"Í∞ÄÍ≤© {p['price']}", value=p["name"]))
        else:
            opts=[discord.SelectOption(label="Ìï¥Îãπ Ïπ¥ÌÖåÍ≥†Î¶¨Ïóê Ï†úÌíàÏù¥ ÏóÜÏäµÎãàÎã§", value="__none__")]
        super().__init__(placeholder="Ï†úÌíàÏùÑ ÏÑ†ÌÉùÌïòÏÑ∏Ïöî", min_values=1, max_values=1, options=opts, custom_id=f"prod_sel_clean_{owner_id}")
        self.owner_id=owner_id; self.category=category
    async def callback(self, it: discord.Interaction):
        if it.user.id!=self.owner_id:
            await it.response.send_message("ÏûëÏÑ±ÏûêÎßå ÏÇ¨Ïö©Ìï† Ïàò ÏûàÏñ¥.", ephemeral=True); return
        val=self.values[0]
        if val=="__none__":
            await it.response.send_message("Î®ºÏ†Ä Ï†úÌíàÏùÑ Ï∂îÍ∞ÄÌï¥Ï£ºÏÑ∏Ïöî.", ephemeral=True); return
        await it.response.send_modal(QuantityModal(self.owner_id, self.category, val))

class CategorySelectForBuy(discord.ui.Select):
    def __init__(self, owner_id:int):
        cats=DB["categories"]
        if cats:
            opts=[]
            for c in cats[:25]:
                opts.append(discord.SelectOption(label=c["name"], value=c["name"], description=(c.get("desc")[:80] if c.get("desc") else None)))
        else:
            opts=[discord.SelectOption(label="Îì±Î°ùÎêú Ïπ¥ÌÖåÍ≥†Î¶¨Í∞Ä ÏóÜÏäµÎãàÎã§", value="__none__")]
        super().__init__(placeholder="Ïπ¥ÌÖåÍ≥†Î¶¨Î•º ÏÑ†ÌÉùÌïòÏÑ∏Ïöî", min_values=1, max_values=1, options=opts, custom_id=f"cat_buy_{owner_id}")
        self.owner_id=owner_id
    async def callback(self, it: discord.Interaction):
        if it.user.id!=self.owner_id:
            await it.response.send_message("ÏûëÏÑ±ÏûêÎßå ÏÇ¨Ïö©Ìï† Ïàò ÏûàÏñ¥.", ephemeral=True); return
        val=self.values[0]
        if val=="__none__":
            await it.response.send_message("Î®ºÏ†Ä Ïπ¥ÌÖåÍ≥†Î¶¨Î•º Ï∂îÍ∞ÄÌï¥Ï£ºÏÑ∏Ïöî.", ephemeral=True); return
        # Í∞ôÏùÄ Î©îÏãúÏßÄÎ•º Ï†úÌíà ÏÑ†ÌÉù ÌôîÎ©¥ÏúºÎ°ú 'ÏàòÏ†ï'
        e_prod = build_product_embed(val)
        v=discord.ui.View(timeout=None); v.add_item(ProductSelectClean(self.owner_id, val))
        await it.response.defer(ephemeral=True)
        await edit_flow_message(it, e_prod, v)
        # Îã®Í≥Ñ Ï†ÄÏû•
        FLOW.setdefault(str(it.guild.id), {}).setdefault(str(it.user.id), {})
        FLOW[str(it.guild.id)][str(it.user.id)]["phase"]="product"
        FLOW[str(it.guild.id)][str(it.user.id)]["category"]=val

class CategorySelectForBuyView(discord.ui.View):
    def __init__(self, owner_id:int):
        super().__init__(timeout=None); self.add_item(CategorySelectForBuy(owner_id))

# ===== Î≤ÑÌäº Ìå®ÎÑê =====
class ButtonPanel(discord.ui.View):
    def __init__(self):
        super().__init__(timeout=None)
        n=discord.ui.Button(label="Í≥µÏßÄÏÇ¨Ìï≠", style=discord.ButtonStyle.secondary, emoji=safe_emoji(EMOJI_NOTICE), row=0)
        c=discord.ui.Button(label="Ï∂©Ï†Ñ",   style=discord.ButtonStyle.secondary, emoji=safe_emoji(EMOJI_CHARGE), row=0)
        i=discord.ui.Button(label="ÎÇ¥ Ï†ïÎ≥¥", style=discord.ButtonStyle.secondary, emoji=safe_emoji(EMOJI_TICKET), row=1)
        b=discord.ui.Button(label="Íµ¨Îß§",   style=discord.ButtonStyle.secondary, emoji=safe_emoji(EMOJI_BUY), row=1)

        async def _notice(it):
            await it.response.send_message(embed=set_v2(discord.Embed(
                title="Í≥µÏßÄÏÇ¨Ìï≠", description="ÏÑúÎ≤ÑÍ∑úÏπô ÌïÑÎèÖ Î∂ÄÌÉÅÎìúÎ¶ΩÎãàÎã§\nÏûêÏ∂© Ïò§Î•òÏãú Ìã∞Ïºì Ïó¥Ïñ¥Ï£ºÏÑ∏Ïöî", color=GRAY
            )), ephemeral=True)

        async def _charge(it):
            if ban_is_blocked(it.guild.id, it.user.id):
                await it.response.send_message(embed=set_v2(discord.Embed(
                    title="Ïù¥Ïö© Î∂àÍ∞Ä", description="Ï∞®Îã® ÏÉÅÌÉúÏûÖÎãàÎã§. /Ïú†Ï†Ä_ÏÑ§Ï†ïÏúºÎ°ú Ìï¥Ï†úÌïòÏÑ∏Ïöî.", color=RED
                )), ephemeral=True); return
            view=PaymentMethodView()
            if len(view.children)==0:
                await it.response.send_message(embed=set_v2(discord.Embed(
                    title="Í≤∞Ï†úÏàòÎã® ÏÑ†ÌÉùÌïòÍ∏∞", description="ÌòÑÏû¨ ÏßÄÏõêÎêòÎäî Í≤∞Ï†úÏàòÎã®Ïù¥ ÏóÜÏäµÎãàÎã§.", color=ORANGE
                )), ephemeral=True)
            else:
                await it.response.send_message(embed=set_v2(discord.Embed(
                    title="Í≤∞Ï†úÏàòÎã® ÏÑ†ÌÉùÌïòÍ∏∞", description="ÏõêÌïòÏãúÎäî Í≤∞Ï†úÏàòÎã® Î≤ÑÌäºÏùÑ ÌÅ¥Î¶≠Ìï¥Ï£ºÏÑ∏Ïöî", color=GRAY
                )), view=view, ephemeral=True)

        async def _info(it):
            gid=it.guild.id; uid=it.user.id
            ords=orders_get(gid, uid); spent=0
            for o in ords:
                p=next((pp for pp in DB["products"] if pp["name"]==o["product"]), None)
                if p: spent += p["price"]*o["qty"]
            bal=bal_get(gid, uid); pts=pt_get(gid, uid)
            line="„Ö°"*18
            desc=f"Î≥¥Ïú† Í∏àÏï° : {bal}\nÎàÑÏ†Å Í∏àÏï° : {spent}\nÌè¨Ïù∏Ìä∏ : {pts}\nÍ±∞Îûò ÌöüÏàò : {len(ords)}\n{line}\nÏó≠Ìï†Îì±Í∏â : ÏïÑÏßÅ ÏóÜÏäµÎãàÎã§\nÏó≠Ìï†ÌòúÌÉù : ÏïÑÏßÅ ÏóÜÏäµÎãàÎã§"
            e=set_v2(discord.Embed(title="ÎÇ¥ Ï†ïÎ≥¥", description=desc, color=GRAY))
            try: e.set_thumbnail(url=it.user.display_avatar.url)
            except: pass
            await it.response.send_message(embed=e, view=MyInfoView(uid, ords), ephemeral=True)

        async def _buy(it):
            if ban_is_blocked(it.guild.id, it.user.id):
                await it.response.send_message(embed=set_v2(discord.Embed(
                    title="Ïù¥Ïö© Î∂àÍ∞Ä", description="Ï∞®Îã® ÏÉÅÌÉúÏûÖÎãàÎã§. /Ïú†Ï†Ä_ÏÑ§Ï†ïÏúºÎ°ú Ìï¥Ï†úÌïòÏÑ∏Ïöî.", color=RED
                )), ephemeral=True); return
            # Ïπ¥ÌÖåÍ≥†Î¶¨ ÏûÑÎ≤†Îìú + ÏïÑÎûò ÎìúÎ°≠Îã§Ïö¥(Í∞ôÏùÄ Î©îÏãúÏßÄ ÏàòÏ†ï Í∏∞Î∞òÏúºÎ°ú Ïö¥Ïö©)
            e = build_category_embed()
            await it.response.send_message(embed=e, ephemeral=True)
            await remember_flow_message(it, phase="category")
            # Í∞ôÏùÄ Î©îÏãúÏßÄÏóê ÎìúÎ°≠Îã§Ïö¥ÏùÑ Î∂ôÏù¥Î†§Î©¥ edit ÌïÑÏöî ‚Üí original_response Í∞ÄÏ†∏ÏôÄÏÑú editÎ°ú view Î∂ÄÏ∞©
            try:
                msg = await it.original_response()
                v = CategorySelectForBuyView(it.user.id)
                await msg.edit(view=v)
            except: pass

        n.callback=_notice; c.callback=_charge; i.callback=_info; b.callback=_buy
        self.add_item(n); self.add_item(c); self.add_item(i); self.add_item(b)

# ===== Î∑∞: ÎÇ¥ Ï†ïÎ≥¥ ÎìúÎ°≠Îã§Ïö¥ =====
class RecentOrdersSelect(discord.ui.Select):
    def __init__(self, owner_id:int, orders:list[dict]):
        opts=[]
        for o in orders[-5:][::-1]:
            ts=time.strftime('%Y-%m-%d %H:%M', time.localtime(o['ts']))
            opts.append(discord.SelectOption(label=f"{o['product']} x{o['qty']}", description=ts, value=f"{o['product']}||{o['qty']}||{o['ts']}"))
        if not opts:
            opts=[discord.SelectOption(label="ÏµúÍ∑º Íµ¨Îß§ ÏóÜÏùå", value="__none__", description="ÌëúÏãúÌï† Ìï≠Î™©Ïù¥ ÏóÜÏäµÎãàÎã§")]
        super().__init__(placeholder="ÏµúÍ∑º Íµ¨Îß§ ÎÇ¥Ïó≠ Î≥¥Í∏∞", min_values=1, max_values=1, options=opts, custom_id=f"recent_{owner_id}")
        self.owner_id=owner_id
    async def callback(self, it: discord.Interaction):
        if it.user.id!=self.owner_id:
            await it.response.send_message("ÏûëÏÑ±ÏûêÎßå Î≥º Ïàò ÏûàÏñ¥.", ephemeral=True); return
        val=self.values[0]
        if val=="__none__":
            await it.response.send_message("ÏµúÍ∑º Íµ¨Îß§Í∞Ä ÏóÜÏäµÎãàÎã§.", ephemeral=True); return
        name, qty, ts = val.split("||")
        ts_str=time.strftime('%Y-%m-%d %H:%M', time.localtime(int(ts)))
        await it.response.send_message(embed=set_v2(discord.Embed(
            title="Íµ¨Îß§ ÏÉÅÏÑ∏", description=f"- Ï†úÌíà: {name}\n- ÏàòÎüâ: {qty}\n- ÏãúÍ∞Ñ: {ts_str}", color=GRAY
        )), ephemeral=True)

class MyInfoView(discord.ui.View):
    def __init__(self, owner_id:int, orders:list[dict]):
        super().__init__(timeout=None); self.add_item(RecentOrdersSelect(owner_id, orders))

# ===== Í¥ÄÎ¶¨Ïûê Î≥¥Ìò∏ =====
def is_admin():
    async def predicate(interaction: discord.Interaction):
        if interaction.user.guild_permissions.manage_guild:
            return True
        await interaction.response.send_message("Í¥ÄÎ¶¨ÏûêÎßå ÏÇ¨Ïö©Ìï† Ïàò ÏûàÏñ¥.", ephemeral=True)
        return False
    return app_commands.check(predicate)

# ===== Ïπ¥ÌÖåÍ≥†Î¶¨/Ï†úÌíà/Ïû¨Í≥†/Î°úÍ∑∏ ÏÑ§Ï†ï Ïä¨ÎûòÏãú(10Í∞ú) =====
class CategoryDeleteView(discord.ui.View):
    def __init__(self, owner_id:int):
        super().__init__(timeout=None)
        class CategoryDeleteSelect(discord.ui.Select):
            def __init__(self, owner_id:int):
                cats=DB["categories"]; opts=[]
                for c in cats[:25]:
                    opts.append(discord.SelectOption(label=c["name"], value=c["name"], description=(c.get("desc")[:80] if c.get("desc") else None)))
                super().__init__(placeholder="ÏÇ≠Ï†úÌï† Ïπ¥ÌÖåÍ≥†Î¶¨Î•º ÏÑ†ÌÉùÌïòÏÑ∏Ïöî", min_values=1, max_values=1, options=opts or [discord.SelectOption(label="ÏÇ≠Ï†úÌï† Ïπ¥ÌÖåÍ≥†Î¶¨Í∞Ä ÏóÜÏäµÎãàÎã§", value="__none__")], custom_id=f"cat_del_{owner_id}")
                self.owner_id=owner_id
            async def callback(self, it: discord.Interaction):
                if it.user.id!=self.owner_id:
                    await it.response.send_message("ÏûëÏÑ±ÏûêÎßå ÏÑ†ÌÉùÌï† Ïàò ÏûàÏñ¥.", ephemeral=True); return
                val=self.values[0]
                if val=="__none__":
                    await it.response.send_message("ÏÇ≠Ï†úÌï† Ïπ¥ÌÖåÍ≥†Î¶¨Í∞Ä ÏóÜÏäµÎãàÎã§.", ephemeral=True); return
                DB["categories"]=[c for c in DB["categories"] if c["name"]!=val]
                DB["products"]=[p for p in DB["products"] if p["category"]!=val]; db_save()
                await it.response.send_message(embed=set_v2(discord.Embed(
                    title="Ïπ¥ÌÖåÍ≥†Î¶¨ ÏÇ≠Ï†ú ÏôÑÎ£å", description=f"ÏÇ≠Ï†úÎêú Ïπ¥ÌÖåÍ≥†Î¶¨: {val}", color=GRAY
                )), ephemeral=True)
        self.add_item(CategoryDeleteSelect(owner_id))

class CategorySetupModal(discord.ui.Modal, title="Ïπ¥ÌÖåÍ≥†Î¶¨ Ï∂îÍ∞Ä"):
    name_input = discord.ui.TextInput(label="Ïπ¥ÌÖåÍ≥†Î¶¨ Ïù¥Î¶Ñ", required=True, max_length=60)
    desc_input = discord.ui.TextInput(label="Ïπ¥ÌÖåÍ≥†Î¶¨ ÏÑ§Î™Ö", style=discord.TextStyle.paragraph, required=False, max_length=200)
    emoji_input= discord.ui.TextInput(label="Ïπ¥ÌÖåÍ≥†Î¶¨ Ïù¥Î™®ÏßÄ", required=False, max_length=100)
    def __init__(self, owner_id:int):
        super().__init__(); self.owner_id=owner_id
    async def on_submit(self, it: discord.Interaction):
        if it.user.id!=self.owner_id:
            await it.response.send_message("ÏûëÏÑ±ÏûêÎßå ÏÇ¨Ïö©Ìï† Ïàò ÏûàÏñ¥.", ephemeral=True); return
        name=str(self.name_input.value).strip()
        desc=str(self.desc_input.value).strip() if self.desc_input.value else ""
        emoji=str(self.emoji_input.value).strip() if self.emoji_input.value else ""
        i=next((k for k,c in enumerate(DB["categories"]) if c["name"]==name), -1)
        row={"name":name,"desc":desc,"emoji_raw":emoji}
        if i>=0: DB["categories"][i]=row
        else: DB["categories"].append(row)
        db_save()
        await it.response.send_message(embed=set_v2(discord.Embed(
            title="Ïπ¥ÌÖåÍ≥†Î¶¨ Îì±Î°ù ÏôÑÎ£å", description=f"{name}\n{desc}", color=GRAY
        )), ephemeral=True)

class ProductSetupModal(discord.ui.Modal, title="Ï†úÌíà Ï∂îÍ∞Ä"):
    name_input = discord.ui.TextInput(label="Ï†úÌíà Ïù¥Î¶Ñ", required=True, max_length=60)
    category_input = discord.ui.TextInput(label="Ïπ¥ÌÖåÍ≥†Î¶¨ Ïù¥Î¶Ñ", required=True, max_length=60)
    price_input = discord.ui.TextInput(label="Ï†úÌíà Í∞ÄÍ≤©(Ïõê)", required=True, max_length=10)
    emoji_input = discord.ui.TextInput(label="Ï†úÌíà Ïù¥Î™®ÏßÄ", required=False, max_length=100)
    desc_input  = discord.ui.TextInput(label="Ï†úÌíà ÏÑ§Î™Ö", style=discord.TextStyle.paragraph, required=False, max_length=400)
    def __init__(self, owner_id:int):
        super().__init__(); self.owner_id=owner_id
    async def on_submit(self, it: discord.Interaction):
        if it.user.id!=self.owner_id:
            await it.response.send_message("ÏûëÏÑ±ÏûêÎßå Ï†úÏ∂úÌï† Ïàò ÏûàÏñ¥.", ephemeral=True); return
        name=str(self.name_input.value).strip()
        cat=str(self.category_input.value).strip()
        price_s=str(self.price_input.value).strip()
        if not any(c["name"]==cat for c in DB["categories"]):
            await it.response.send_message("Ìï¥Îãπ Ïπ¥ÌÖåÍ≥†Î¶¨Í∞Ä Ï°¥Ïû¨ÌïòÏßÄ ÏïäÏäµÎãàÎã§.", ephemeral=True); return
        if not price_s.isdigit():
            await it.response.send_message("Í∞ÄÍ≤©ÏùÄ Ïà´ÏûêÎßå ÏûÖÎ†•Ìï¥Ï§ò.", ephemeral=True); return
        price=int(price_s)
        emoji=str(self.emoji_input.value).strip() if self.emoji_input.value else ""
        desc=str(self.desc_input.value).strip() if self.desc_input.value else ""
        prod_upsert(name, cat, price, emoji, desc)
        await it.response.send_message(embed=set_v2(discord.Embed(
            title="Ï†úÌíà Îì±Î°ù ÏôÑÎ£å", description=f"{name}\nÏπ¥ÌÖåÍ≥†Î¶¨: {cat}\nÍ∞ÄÍ≤©: {price}\n(ÏÑ§Î™Ö Ï†ÄÏû•Îê®)", color=GRAY
        )), ephemeral=True)

class ProductDeleteView(discord.ui.View):
    def __init__(self, owner_id:int):
        super().__init__(timeout=None)
        class ProductDeleteSelect(discord.ui.Select):
            def __init__(self, owner_id:int):
                ps=prod_list_all(); opts=[]
                for p in ps[:25]:
                    opts.append(discord.SelectOption(label=p["name"], value=f"{p['name']}||{p['category']}", description=f"{p['category']}"))
                super().__init__(placeholder="ÏÇ≠Ï†úÌï† Ï†úÌíàÏùÑ ÏÑ†ÌÉùÌïòÏÑ∏Ïöî", min_values=1, max_values=1, options=opts or [discord.SelectOption(label="ÏÇ≠Ï†úÌï† Ï†úÌíàÏù¥ ÏóÜÏäµÎãàÎã§", value="__none__")], custom_id=f"prod_del_{owner_id}")
                self.owner_id=owner_id
            async def callback(self, it: discord.Interaction):
                if it.user.id!=self.owner_id:
                    await it.response.send_message("ÏûëÏÑ±ÏûêÎßå ÏÑ†ÌÉùÌï† Ïàò ÏûàÏñ¥.", ephemeral=True); return
                val=self.values[0]
                if val=="__none__":
                    await it.response.send_message("ÏÇ≠Ï†úÌï† Ï†úÌíàÏù¥ ÏóÜÏäµÎãàÎã§.", ephemeral=True); return
                name,cat=val.split("||",1)
                prod_delete(name, cat)
                await it.response.send_message(embed=set_v2(discord.Embed(
                    title="Ï†úÌíà ÏÇ≠Ï†ú ÏôÑÎ£å", description=f"ÏÇ≠Ï†úÎêú Ï†úÌíà: {name} (Ïπ¥ÌÖåÍ≥†Î¶¨: {cat})", color=GRAY
                )), ephemeral=True)
        self.add_item(ProductDeleteSelect(owner_id))

class ControlCog(commands.Cog):
    def __init__(self, bot_:commands.Bot):
        self.bot=bot_

    @app_commands.command(name="Î≤ÑÌäºÌå®ÎÑê", description="Î≤ÑÌäº Ìå®ÎÑêÏùÑ ÌëúÏãúÌï©ÎãàÎã§.")
    @app_commands.guilds(GUILD)
    async def Î≤ÑÌäºÌå®ÎÑê(self, it: discord.Interaction):
        await it.response.send_message(embed=set_v2(discord.Embed(
            title="ÏúàÎìú OTT", description="ÏïÑÎûò Î≤ÑÌäºÏúºÎ°ú Ïù¥Ïö©Ìï¥Ï£ºÏÑ∏Ïöî!", color=GRAY
        )), view=ButtonPanel())

    @app_commands.command(name="Ïπ¥ÌÖåÍ≥†Î¶¨_ÏÑ§Ï†ï", description="Íµ¨Îß§ Ïπ¥ÌÖåÍ≥†Î¶¨Î•º ÏÑ§Ï†ïÌï©ÎãàÎã§.")
    @app_commands.guilds(GUILD)
    @is_admin()
    async def Ïπ¥ÌÖåÍ≥†Î¶¨_ÏÑ§Ï†ï(self, it:discord.Interaction):
        view=discord.ui.View(timeout=None)
        class Root(discord.ui.Select):
            def __init__(self, owner_id:int):
                super().__init__(placeholder="Ïπ¥ÌÖåÍ≥†Î¶¨ ÏÑ§Ï†ïÌïòÍ∏∞", min_values=1, max_values=1,
                                 options=[discord.SelectOption(label="Ïπ¥ÌÖåÍ≥†Î¶¨ Ï∂îÍ∞Ä", value="add"),
                                          discord.SelectOption(label="Ïπ¥ÌÖåÍ≥†Î¶¨ ÏÇ≠Ï†ú", value="del")],
                                 custom_id=f"cat_root_{owner_id}")
                self.owner_id=owner_id
            async def callback(self, inter:discord.Interaction):
                if inter.user.id!=self.owner_id:
                    await inter.response.send_message("ÏûëÏÑ±ÏûêÎßå ÏÇ¨Ïö©Ìï† Ïàò ÏûàÏñ¥.", ephemeral=True); return
                if self.values[0]=="add":
                    await inter.response.send_modal(CategorySetupModal(self.owner_id))
                else:
                    await inter.response.send_message(embed=set_v2(discord.Embed(
                        title="Ïπ¥ÌÖåÍ≥†Î¶¨ ÏÇ≠Ï†ú", description="ÏÇ≠Ï†úÌï† Ïπ¥ÌÖåÍ≥†Î¶¨Î•º ÏÑ†ÌÉùÌïòÏÑ∏Ïöî.", color=GRAY
                    )), view=CategoryDeleteView(self.owner_id), ephemeral=True)
        view.add_item(Root(it.user.id))
        await it.response.send_message(embed=set_v2(discord.Embed(
            title="Ïπ¥ÌÖåÍ≥†Î¶¨ ÏÑ§Ï†ïÌïòÍ∏∞", description="Ïπ¥ÌÖåÍ≥†Î¶¨ ÏÑ§Ï†ïÌï¥Ï£ºÏÑ∏Ïöî", color=GRAY
        )), view=view, ephemeral=True)

    @app_commands.command(name="Ï†úÌíà_ÏÑ§Ï†ï", description="Ï†úÌíàÏùÑ Ï∂îÍ∞Ä/ÏÇ≠Ï†úÎ°ú Í¥ÄÎ¶¨Ìï©ÎãàÎã§.")
    @app_commands.guilds(GUILD)
    @is_admin()
    async def Ï†úÌíà_ÏÑ§Ï†ï(self, it:discord.Interaction):
        view=discord.ui.View(timeout=None)
        class Root(discord.ui.Select):
            def __init__(self, owner_id:int):
                super().__init__(placeholder="Ï†úÌíà ÏÑ§Ï†ïÌïòÍ∏∞", min_values=1, max_values=1,
                                 options=[discord.SelectOption(label="Ï†úÌíà Ï∂îÍ∞Ä", value="add"),
                                          discord.SelectOption(label="Ï†úÌíà ÏÇ≠Ï†ú", value="del")],
                                 custom_id=f"prod_root_{owner_id}")
                self.owner_id=owner_id
            async def callback(self, inter:discord.Interaction):
                if inter.user.id!=self.owner_id:
                    await inter.response.send_message("ÏûëÏÑ±ÏûêÎßå ÏÇ¨Ïö©Ìï† Ïàò ÏûàÏñ¥.", ephemeral=True); return
                if self.values[0]=="add":
                    await inter.response.send_modal(ProductSetupModal(self.owner_id))
                else:
                    await inter.response.send_message(embed=set_v2(discord.Embed(
                        title="Ï†úÌíà ÏÇ≠Ï†ú", description="ÏÇ≠Ï†úÌï† Ï†úÌíàÏùÑ ÏÑ†ÌÉùÌïòÏÑ∏Ïöî.", color=GRAY
                    )), view=ProductDeleteView(self.owner_id), ephemeral=True)
        view.add_item(Root(it.user.id))
        await it.response.send_message(embed=set_v2(discord.Embed(
            title="Ï†úÌíà ÏÑ§Ï†ïÌïòÍ∏∞", description="Ï†úÌíà ÏÑ§Ï†ïÌï¥Ï£ºÏÑ∏Ïöî", color=GRAY
        )), view=view, ephemeral=True)

    @app_commands.command(name="Ïû¨Í≥†_ÏÑ§Ï†ï", description="Ï†úÌíà Ïû¨Í≥†Î•º Ï∂îÍ∞ÄÌï©ÎãàÎã§.")
    @app_commands.guilds(GUILD)
    @is_admin()
    async def Ïû¨Í≥†_ÏÑ§Ï†ï(self, it:discord.Interaction):
        class StockSel(discord.ui.Select):
            def __init__(self, owner_id:int):
                ps=prod_list_all()
                opts=[]
                if ps:
                    for p in ps[:25]:
                        opts.append(discord.SelectOption(label=f"{p['name']} ({p['category']})", value=f"{p['name']}||{p['category']}", description=f"Í∞ÄÍ≤© {p['price']}"))
                else:
                    opts=[discord.SelectOption(label="Îì±Î°ùÎêú Ï†úÌíàÏù¥ ÏóÜÏäµÎãàÎã§", value="__none__")]
                super().__init__(placeholder="Ïû¨Í≥†Î•º ÏÑ§Ï†ïÌï† Ï†úÌíàÏùÑ ÏÑ†ÌÉù", min_values=1, max_values=1, options=opts, custom_id=f"stock_prod_{owner_id}")
                self.owner_id=owner_id
            async def callback(self, inter:discord.Interaction):
                if inter.user.id!=self.owner_id:
                    await inter.response.send_message("ÏûëÏÑ±ÏûêÎßå ÏÇ¨Ïö©Ìï† Ïàò ÏûàÏñ¥.", ephemeral=True); return
                val=self.values[0]
                if val=="__none__":
                    await inter.response.send_message("Î®ºÏ†Ä Ï†úÌíàÏùÑ Ï∂îÍ∞ÄÌï¥Ï£ºÏÑ∏Ïöî.", ephemeral=True); return
                name,cat=val.split("||",1)
                await inter.response.send_modal(StockAddModal(self.owner_id, name, cat))
        view=discord.ui.View(timeout=None); view.add_item(StockSel(it.user.id))
        await it.response.send_message(embed=set_v2(discord.Embed(
            title="Ïû¨Í≥† ÏÑ§Ï†ïÌïòÍ∏∞", description="Ïû¨Í≥† ÏÑ§Ï†ïÌï¥Ï£ºÏÑ∏Ïöî", color=GRAY
        )), view=view, ephemeral=True)

    @app_commands.command(name="Î°úÍ∑∏_ÏÑ§Ï†ï", description="Íµ¨Îß§Î°úÍ∑∏/Íµ¨Îß§ÌõÑÍ∏∞/Í¥ÄÎ¶¨ÏûêÎ°úÍ∑∏/Î≥¥ÏïàÏ±ÑÎÑêÏùÑ ÏÑ§Ï†ïÌï©ÎãàÎã§.")
    @app_commands.guilds(GUILD)
    @is_admin()
    async def Î°úÍ∑∏_ÏÑ§Ï†ï(self, it:discord.Interaction):
        class LogChannelIdModal(discord.ui.Modal, title="Î°úÍ∑∏ Ï±ÑÎÑê ÏÑ§Ï†ï"):
            channel_id_input = discord.ui.TextInput(label="Ï±ÑÎÑê ID", required=True, max_length=25)
            def __init__(self, owner_id:int, log_key:str):
                super().__init__(); self.owner_id=owner_id; self.log_key=log_key
            async def on_submit(self, inter:discord.Interaction):
                if inter.user.id!=self.owner_id:
                    await inter.response.send_message("ÏûëÏÑ±ÏûêÎßå Ï†úÏ∂úÌï† Ïàò ÏûàÏñ¥.", ephemeral=True); return
                raw=str(self.channel_id_input.value).strip()
                if not raw.isdigit():
                    await inter.response.send_message(embed=set_v2(discord.Embed(
                        title="Ïã§Ìå®", description="Ï±ÑÎÑê IDÎäî Ïà´ÏûêÏó¨Ïïº Ìï©ÎãàÎã§.", color=RED
                    )), ephemeral=True); return
                ch=inter.guild.get_channel(int(raw))
                if not isinstance(ch, discord.TextChannel):
                    await inter.response.send_message(embed=set_v2(discord.Embed(
                        title="Ïã§Ìå®", description="Ïú†Ìö®Ìïú ÌÖçÏä§Ìä∏ Ï±ÑÎÑê IDÍ∞Ä ÏïÑÎãôÎãàÎã§.", color=RED
                    )), ephemeral=True); return
                DB["logs"].setdefault(self.log_key, {"enabled": False, "target_channel_id": None})
                DB["logs"][self.log_key]["target_channel_id"]=int(raw)
                DB["logs"][self.log_key]["enabled"]=True; db_save()
                pretty={"purchase":"Íµ¨Îß§Î°úÍ∑∏","review":"Íµ¨Îß§ÌõÑÍ∏∞","admin":"Í¥ÄÎ¶¨ÏûêÎ°úÍ∑∏","secure":"Î≥¥ÏïàÏ±ÑÎÑê"}[self.log_key]
                await inter.response.send_message(embed=set_v2(discord.Embed(
                    title=f"{pretty} Ï±ÑÎÑê ÏßÄÏ†ï ÏôÑÎ£å", description=f"Î™©Ï†ÅÏßÄ: {ch.mention}", color=GRAY
                )), ephemeral=True)
        class Root(discord.ui.Select):
            def __init__(self, owner_id:int):
                options=[discord.SelectOption(label="Íµ¨Îß§Î°úÍ∑∏ ÏÑ§Ï†ï", value="purchase"),
                         discord.SelectOption(label="Íµ¨Îß§ÌõÑÍ∏∞ ÏÑ§Ï†ï", value="review"),
                         discord.SelectOption(label="Í¥ÄÎ¶¨ÏûêÎ°úÍ∑∏ ÏÑ§Ï†ï", value="admin"),
                         discord.SelectOption(label="Î≥¥ÏïàÏ±ÑÎÑê ÏÑ§Ï†ï(Ï∂©Ï†ÑÏäπÏù∏)", value="secure")]
                super().__init__(placeholder="ÏÑ§Ï†ïÌï† Î°úÍ∑∏ Ïú†Ìòï ÏÑ†ÌÉù", min_values=1, max_values=1, options=options, custom_id=f"log_root_{owner_id}")
                self.owner_id=owner_id
            async def callback(self, inter:discord.Interaction):
                if inter.user.id!=self.owner_id:
                    await inter.response.send_message("ÏûëÏÑ±ÏûêÎßå ÏÇ¨Ïö©Ìï† Ïàò ÏûàÏñ¥.", ephemeral=True); return
                await inter.response.send_modal(LogChannelIdModal(self.owner_id, self.values[0]))
        view=discord.ui.View(timeout=None); view.add_item(Root(it.user.id))
        await it.response.send_message(embed=set_v2(discord.Embed(
            title="Î°úÍ∑∏ ÏÑ§Ï†ïÌïòÍ∏∞", description="Î°úÍ∑∏/Î≥¥Ïïà Ï±ÑÎÑêÏùÑ ÏÑ§Ï†ïÌï¥Ï£ºÏÑ∏Ïöî", color=GRAY
        )), view=view, ephemeral=True)

    @app_commands.command(name="ÏûîÏï°_ÏÑ§Ï†ï", description="Ïú†Ï†Ä ÏûîÏï°ÏùÑ Ï∂îÍ∞Ä/Ï∞®Í∞êÌï©ÎãàÎã§.")
    @app_commands.guilds(GUILD)
    @is_admin()
    @app_commands.describe(Ïú†Ï†Ä="ÎåÄÏÉÅ Ïú†Ï†Ä", Í∏àÏï°="Ï†ïÏàò Í∏àÏï°", Ïó¨Î∂Ä="Ï∂îÍ∞Ä/Ï∞®Í∞ê")
    @app_commands.choices(Ïó¨Î∂Ä=[app_commands.Choice(name="Ï∂îÍ∞Ä", value="Ï∂îÍ∞Ä"),
                               app_commands.Choice(name="Ï∞®Í∞ê", value="Ï∞®Í∞ê")])
    async def ÏûîÏï°_ÏÑ§Ï†ï(self, it:discord.Interaction, Ïú†Ï†Ä:discord.Member, Í∏àÏï°:int, Ïó¨Î∂Ä:app_commands.Choice[str]):
        if Í∏àÏï°<0:
            await it.response.send_message("Í∏àÏï°ÏùÄ ÏùåÏàòÍ∞Ä Îê† Ïàò ÏóÜÏñ¥.", ephemeral=True); return
        gid=it.guild.id; uid=Ïú†Ï†Ä.id; prev=bal_get(gid, uid)
        if Ïó¨Î∂Ä.value=="Ï∞®Í∞ê":
            bal_sub(gid, uid, Í∏àÏï°); after=bal_get(gid, uid); color=RED; title=f"{Ïú†Ï†Ä} Í∏àÏï° Ï∞®Í∞ê"
        else:
            bal_add(gid, uid, Í∏àÏï°); after=bal_get(gid, uid); color=GREEN; title=f"{Ïú†Ï†Ä} Í∏àÏï° Ï∂îÍ∞Ä"
        await it.response.send_message(embed=set_v2(discord.Embed(
            title=title, description=f"ÏõêÎûò Í∏àÏï° : {prev}\nÎ≥ÄÍ≤Ω Í∏àÏï° : {Í∏àÏï°}\nÎ≥ÄÍ≤Ω ÌõÑ Í∏àÏï° : {after}", color=color
        )), ephemeral=True)

    @app_commands.command(name="Í≤∞Ï†úÏàòÎã®_ÏÑ§Ï†ï", description="Í≤∞Ï†úÏàòÎã® ÏßÄÏõê Ïó¨Î∂ÄÎ•º ÏÑ§Ï†ïÌï©ÎãàÎã§.")
    @app_commands.guilds(GUILD)
    @is_admin()
    @app_commands.describe(Í≥ÑÏ¢åÏù¥Ï≤¥="ÏßÄÏõê/ÎØ∏ÏßÄÏõê", ÏΩîÏù∏Ï∂©Ï†Ñ="ÏßÄÏõê/ÎØ∏ÏßÄÏõê", Î¨∏ÏÉÅÏ∂©Ï†Ñ="ÏßÄÏõê/ÎØ∏ÏßÄÏõê")
    @app_commands.choices(
        Í≥ÑÏ¢åÏù¥Ï≤¥=[app_commands.Choice(name="ÏßÄÏõê", value="ÏßÄÏõê"), app_commands.Choice(name="ÎØ∏ÏßÄÏõê", value="ÎØ∏ÏßÄÏõê")],
        ÏΩîÏù∏Ï∂©Ï†Ñ=[app_commands.Choice(name="ÏßÄÏõê", value="ÏßÄÏõê"), app_commands.Choice(name="ÎØ∏ÏßÄÏõê", value="ÎØ∏ÏßÄÏõê")],
        Î¨∏ÏÉÅÏ∂©Ï†Ñ=[app_commands.Choice(name="ÏßÄÏõê", value="ÏßÄÏõê"), app_commands.Choice(name="ÎØ∏ÏßÄÏõê", value="ÎØ∏ÏßÄÏõê")]
    )
    async def Í≤∞Ï†úÏàòÎã®_ÏÑ§Ï†ï(self, it:discord.Interaction,
                        Í≥ÑÏ¢åÏù¥Ï≤¥:app_commands.Choice[str],
                        ÏΩîÏù∏Ï∂©Ï†Ñ:app_commands.Choice[str],
                        Î¨∏ÏÉÅÏ∂©Ï†Ñ:app_commands.Choice[str]):
        DB["payments"]["bank"] = (Í≥ÑÏ¢åÏù¥Ï≤¥.value == "ÏßÄÏõê")
        DB["payments"]["coin"] = (ÏΩîÏù∏Ï∂©Ï†Ñ.value == "ÏßÄÏõê")
        DB["payments"]["culture"] = (Î¨∏ÏÉÅÏ∂©Ï†Ñ.value == "ÏßÄÏõê")
        db_save()
        await it.response.send_message(embed=set_v2(discord.Embed(
            title="Í≤∞Ï†úÏàòÎã® ÏÑ§Ï†ï ÏôÑÎ£å",
            description=f"Í≥ÑÏ¢åÏù¥Ï≤¥: {Í≥ÑÏ¢åÏù¥Ï≤¥.value}\nÏΩîÏù∏Ï∂©Ï†Ñ: {ÏΩîÏù∏Ï∂©Ï†Ñ.value}\nÎ¨∏ÏÉÅÏ∂©Ï†Ñ: {Î¨∏ÏÉÅÏ∂©Ï†Ñ.value}",
            color=GRAY
        )), ephemeral=True)

    @app_commands.command(name="Í≥ÑÏ¢åÎ≤àÌò∏_ÏÑ§Ï†ï", description="ÏùÄÌñâÎ™Ö/Í≥ÑÏ¢åÎ≤àÌò∏/ÏòàÍ∏àÏ£ºÎ•º ÏÑ§Ï†ïÌï©ÎãàÎã§.")
    @app_commands.guilds(GUILD)
    @is_admin()
    async def Í≥ÑÏ¢åÎ≤àÌò∏_ÏÑ§Ï†ï(self, it:discord.Interaction):
        await it.response.send_modal(AccountSetupModal(it.user.id))

    @app_commands.command(name="Ïú†Ï†Ä_ÏÑ§Ï†ï", description="Ïú†Ï†Ä Ï∞®Îã®/Ï∞®Îã®ÌíÄÍ∏∞")
    @app_commands.guilds(GUILD)
    @is_admin()
    @app_commands.describe(Ïú†Ï†Ä="ÎåÄÏÉÅ Ïú†Ï†Ä", Ïó¨Î∂Ä="Ï∞®Îã®ÌïòÍ∏∞/Ï∞®Îã®ÌíÄÍ∏∞")
    @app_commands.choices(Ïó¨Î∂Ä=[app_commands.Choice(name="Ï∞®Îã®ÌïòÍ∏∞", value="ban"),
                               app_commands.Choice(name="Ï∞®Îã®ÌíÄÍ∏∞", value="unban")])
    async def Ïú†Ï†Ä_ÏÑ§Ï†ï(self, it:discord.Interaction, Ïú†Ï†Ä:discord.Member, Ïó¨Î∂Ä:app_commands.Choice[str]):
        gid=str(it.guild.id); uid=str(Ïú†Ï†Ä.id)
        DB["bans"].setdefault(gid, {})
        if Ïó¨Î∂Ä.value=="ban":
            DB["bans"][gid][uid]=True; db_save()
            await it.channel.send(embed=set_v2(discord.Embed(title="Ï∞®Îã®ÌïòÍ∏∞", description=f"{Ïú†Ï†Ä}ÎãòÏùÄ ÏûêÌåêÍ∏∞ Ïù¥Ïö© Î∂àÍ∞ÄÎä•Ìï©ÎãàÎã§\n- Ï∞®Îã®Ìï¥Ï†úÎäî /Ïú†Ï†Ä_ÏÑ§Ï†ï", color=RED)))
            await it.response.send_message("Ï≤òÎ¶¨ ÏôÑÎ£å", ephemeral=True)
        else:
            DB["bans"][gid].pop(uid, None); db_save()
            await it.channel.send(embed=set_v2(discord.Embed(title="Ï∞®Îã®ÌíÄÍ∏∞", description=f"{Ïú†Ï†Ä}ÎãòÏùÄ Îã§Ïãú ÏûêÌåêÍ∏∞ Ïù¥Ïö© Í∞ÄÎä•Ìï©ÎãàÎã§", color=GREEN)))
            await it.response.send_message("Ï≤òÎ¶¨ ÏôÑÎ£å", ephemeral=True)

    @app_commands.command(name="Ïú†Ï†Ä_Ï°∞Ìöå", description="Ïú†Ï†Ä Î≥¥Ïú†/ÎàÑÏ†Å/Ìè¨Ïù∏Ìä∏ Ï°∞Ìöå")
    @app_commands.guilds(GUILD)
    @is_admin()
    async def Ïú†Ï†Ä_Ï°∞Ìöå(self, it:discord.Interaction, Ïú†Ï†Ä:discord.Member):
        gid=it.guild.id; uid=Ïú†Ï†Ä.id
        ords=orders_get(gid, uid); spent=0
        for o in ords:
            p=next((pp for pp in DB["products"] if pp["name"]==o["product"]), None)
            if p: spent += p["price"]*o["qty"]
        bal=bal_get(gid, uid); pts=pt_get(gid, uid)
        await it.response.send_message(embed=set_v2(discord.Embed(
            title=f"{Ïú†Ï†Ä} Ï†ïÎ≥¥",
            description=f"Î≥¥Ïú† Í∏àÏï° : `{bal}`\nÎàÑÏ†Å Í∏àÏï° : `{spent}`\nÌè¨Ïù∏Ìä∏ : `{pts}`\nÍ±∞Îûò ÌöüÏàò : `{len(ords)}`",
            color=GRAY
        )), ephemeral=True)

# ===== FastAPI ÏõπÌõÖ =====
app = FastAPI()

@app.post("/kbank-webhook")
async def kbank_webhook(req: Request):
    try:
        token=(req.headers.get("Authorization") or "").replace("Bearer","").strip()
        if token!=WEBHOOK_SECRET:
            return {"ok": False, "error":"unauthorized"}
        body=await req.json()
        gid=int(body.get("guildId") or body.get("server_id") or 0)
        msg=body.get("msg")
        amount=body.get("amount")
        depositor=body.get("depositor")
        if (amount is None or depositor is None) and isinstance(msg, str):
            a,d=parse_sms(msg)
            if amount is None: amount=a
            if depositor is None: depositor=d
        if not gid:
            return {"ok": False, "error":"guild_required"}
        guild=bot.get_guild(gid)
        if not guild:
            return {"ok": False, "error":"guild_not_found"}
        if amount is None or depositor is None:
            ch=get_log_channel(guild, "admin")
            if ch: await ch.send("[ÏûêÎèôÏ∂©Ï†Ñ] ÌååÏã± Ïã§Ìå®")
            return {"ok": False, "result":"parse_failed"}
        ok,msg2=await handle_deposit(guild, int(amount), str(depositor))
        return {"ok": ok, "result": msg2}
    except Exception as e:
        return {"ok": False, "error": str(e)}

def run_api():
    uvicorn.run(app, host="0.0.0.0", port=int(os.getenv("PORT","8787")), log_level="warning")

# ===== Î∂ÄÌä∏ =====
async def guild_sync(b: commands.Bot):
    try:
        await b.tree.sync(guild=GUILD)
        print("[setup_hook] Í∏∏Îìú Ïã±ÌÅ¨ ÏôÑÎ£å")
    except Exception as e:
        print(f"[setup_hook] Í∏∏Îìú Ïã±ÌÅ¨ Ïã§Ìå®: {e}")

@bot.event
async def setup_hook():
    await bot.add_cog(ControlCog(bot))
    await guild_sync(bot)

@bot.event
async def on_ready():
    print(f"Î°úÍ∑∏Ïù∏: {bot.user} (Ï§ÄÎπÑ ÏôÑÎ£å)")
    t=threading.Thread(target=run_api, daemon=True)
    t.start()

TOKEN=os.getenv("DISCORD_TOKEN", "Ïó¨Í∏∞Ïóê_ÌÜ†ÌÅ∞_ÎÑ£Í∏∞")
bot.run(TOKEN)
