main.py

import os, json, time, re, statistics, threading, hashlib, asyncio, base64, contextlib, sys
import discord
from discord import app_commands
from discord.ext import commands
from fastapi import FastAPI, Request
import uvicorn

# playwright Ï≤¥ÌÅ¨
PLAYWRIGHT_AVAILABLE = False
try:
    from playwright.async_api import async_playwright, TimeoutError as PwTimeout
    PLAYWRIGHT_AVAILABLE = True
except Exception:
    PLAYWRIGHT_AVAILABLE = False

# child watcher Î∞©Ïñ¥
try:
    if sys.platform != "win32":
        loop = asyncio.get_event_loop()
        if hasattr(asyncio, "get_child_watcher"):
            try:
                asyncio.get_child_watcher()
            except NotImplementedError:
                from asyncio import SafeChildWatcher, set_child_watcher
                set_child_watcher(SafeChildWatcher())
except Exception:
    pass

# ===== ÌôòÍ≤Ω =====
GUILD_ID = int(os.getenv("GUILD_ID", "1419200424636055592"))
GUILD = discord.Object(id=GUILD_ID)

GRAY = discord.Color.from_str("#808080")
RED = discord.Color.red()
GREEN = discord.Color.green()
ORANGE = discord.Color.orange()
PINK = discord.Color.from_str("#ff5ea3")

# Ïù¥Î™®ÏßÄ
EMJ_NOTICE   = "<:Announcement:1423544323735027763>"
EMJ_CHARGE   = "<a:Card_Black:1423544325597560842>"
EMJ_INFO     = "<:saknagkang_00000:1371042122345484353>"
EMJ_BUY      = "<:Nitro:1423517143730749490>"
EMJ_TOSS     = "<:TOSS:1423544803559342154>"
EMJ_CULTURE  = "<:1200x630wa:1423544804721164370>"
EMJ_COIN     = "<:bitcoin:1423544805975265374>"
EMJ_APPROVE  = "<a:1209511710545813526:1421430914373779618>"
EMJ_DECLINE  = "<a:1257004507125121105:1421430917049749506>"
EMJ_HEART    = "üíå"

intents = discord.Intents.default()
intents.members = True
bot = commands.Bot(command_prefix="!", intents=intents)

# ===== DB =====
DB_PATH = "data.json"
WEBHOOK_SECRET = os.getenv("WEBHOOK_SECRET", "KBRIDGE_9f8a1c2b0e4a4a7f")
_db_lock = threading.Lock()

def _default_db():
    return {
        "categories": [],
        "products": [],
        "logs": {
            "purchase": {"enabled": False, "target_channel_id": None},
            "review":   {"enabled": False, "target_channel_id": None},
            "admin":    {"enabled": False, "target_channel_id": None},
            "secure":   {"enabled": False, "target_channel_id": None}
        },
        "payments": {"bank": False, "coin": False, "culture": False},
        "balances": {},
        "points": {},
        "orders": {},
        "account": {"bank": "", "number": "", "holder": ""},
        "bans": {},
        "reviews": {},
        "purchases_sent": {},
        "topups": {"requests": [], "receipts": []},
        "culture_accounts": {}  # {gid:{uid:{idEnc,pwEnc,options,cookies[],cookiesAt}}}
    }

def db_load():
    if not os.path.exists(DB_PATH):
        return _default_db()
    try:
        with open(DB_PATH, "r", encoding="utf-8") as f:
            data = json.load(f)
    except Exception:
        return _default_db()
    base=_default_db()
    for k,v in base.items():
        data.setdefault(k,v)
    def _intmap(d):
        out={}
        if isinstance(d, dict):
            for k,v in d.items():
                try: out[str(k)] = int(v)
                except: out[str(k)] = 0
        return out
    data["balances"] = {str(g): _intmap(u) for g,u in data.get("balances",{}).items()}
    data["points"]   = {str(g): _intmap(u) for g,u in data.get("points",{}).items()}
    for k in ("bank","number","holder"):
        data["account"][k] = str(data["account"].get(k,""))
    data["topups"].setdefault("requests", [])
    data["topups"].setdefault("receipts", [])
    data.setdefault("purchases_sent", {})
    data.setdefault("culture_accounts", {})
    return data

def db_save():
    with _db_lock:
        with open(DB_PATH, "w", encoding="utf-8") as f:
            json.dump(DB, f, ensure_ascii=False, indent=2)

DB = db_load()

# ===== Ïú†Ìã∏ =====
CUSTOM_EMOJI_RE = re.compile(r'^<(?P<anim>a?):(?P<name>[A-Za-z0-9_]+):(?P<id>\d+)>$')
def parse_partial_emoji(text: str):
    if not text: return None
    m = CUSTOM_EMOJI_RE.match(text.strip())
    if not m: return None
    try:
        return discord.PartialEmoji(name=m.group("name"), id=int(m.group("id")), animated=(m.group("anim")=="a"))
    except:
        return None

def safe_emoji(raw: str | None):
    pe = parse_partial_emoji(raw or "")
    return pe if pe else None

def _now(): return int(time.time())

def set_v2(e: discord.Embed):
    try: e.set_author(name="")
    except: pass
    try: e.set_footer(text="")
    except: pass
    return e

def star_bar(avg: float | None) -> str:
    if avg is None: return "ÌèâÏ†ê ÏóÜÏùå"
    n = max(1, min(int(round(avg)), 5))
    return "‚≠êÔ∏è"*n

def product_avg_stars(p: dict) -> str:
    ratings = p.get("ratings", [])
    avg = round(statistics.mean(ratings), 1) if ratings else None
    return star_bar(avg)

def category_avg_stars(cat_name: str) -> str:
    ps = [p for p in DB["products"] if p["category"]==cat_name and p.get("ratings")]
    if not ps: return "ÌèâÏ†ê ÏóÜÏùå"
    all_r=[]
    for p in ps: all_r += p.get("ratings", [])
    if not all_r: return "ÌèâÏ†ê ÏóÜÏùå"
    avg = round(statistics.mean(all_r), 1)
    return star_bar(avg)

def ban_is_blocked(gid: int, uid: int) -> bool:
    return bool(DB["bans"].get(str(gid), {}).get(str(uid), False))

def bal_get(gid: int, uid: int) -> int:
    return DB["balances"].get(str(gid), {}).get(str(uid), 0)

def bal_set(gid: int, uid: int, val: int):
    DB["balances"].setdefault(str(gid), {})
    DB["balances"][str(gid)][str(uid)] = int(val); db_save()

def bal_add(gid: int, uid: int, amt: int):
    bal_set(gid, uid, bal_get(gid, uid) + max(0, int(amt)))

def bal_sub(gid: int, uid: int, amt: int):
    bal_set(gid, uid, bal_get(gid, uid) - max(0, int(amt)))

def pt_get(gid: int, uid: int) -> int:
    return DB["points"].get(str(gid), {}).get(str(uid), 0)

def orders_get(gid: int, uid: int):
    return DB.get("orders", {}).get(str(gid), {}).get(str(uid), [])

def orders_add(gid: int, uid: int, product: str, qty: int):
    DB.setdefault("orders", {}).setdefault(str(gid), {}).setdefault(str(uid), []).append(
        {"product": product, "qty": int(qty), "ts": _now()}
    ); db_save()

def prod_get(name: str, category: str):
    return next((p for p in DB["products"] if p["name"]==name and p["category"]==category), None)

def prod_list_by_cat(category: str):
    return [p for p in DB["products"] if p["category"]==category]

def prod_list_all():
    return list(DB["products"])

def prod_upsert(name: str, category: str, price: int, emoji_raw: str = "", desc: str = ""):
    p = prod_get(name, category)
    if p:
        p.update({"price": int(max(0, price)), "emoji_raw": emoji_raw, "desc": desc})
    else:
        DB["products"].append({
            "name": name, "category": category, "price": int(max(0, price)),
            "stock": 0, "items": [], "emoji_raw": emoji_raw, "ratings": [],
            "sold_count": 0, "desc": desc
        })
    db_save()

def prod_delete(name: str, category: str):
    DB["products"] = [p for p in DB["products"] if not (p["name"]==name and p["category"]==category)]
    db_save()

# ===== Î°úÍ∑∏ Ï±ÑÎÑê =====
def get_log_channel(guild: discord.Guild, key: str) -> discord.TextChannel | None:
    cfg = DB["logs"].get(key) or {}
    if not cfg.get("enabled") or not cfg.get("target_channel_id"): return None
    ch = guild.get_channel(int(cfg["target_channel_id"]))
    return ch if isinstance(ch, discord.TextChannel) else None

async def send_log_embed(guild: discord.Guild, key: str, embed: discord.Embed):
    ch = get_log_channel(guild, key)
    if not ch: return False
    try:
        await ch.send(embed=embed); return True
    except: return False

async def send_log_text(guild: discord.Guild, key: str, text: str):
    ch = get_log_channel(guild, key)
    if not ch: return False
    try:
        await ch.send(text); return True
    except: return False

# ===== Íµ¨Îß§/ÌõÑÍ∏∞/DM =====
def emb_purchase_log(user: discord.User, product: str, qty: int):
    return set_v2(discord.Embed(
        title="Íµ¨Îß§Î°úÍ∑∏",
        description=f"{user.mention}Îãò {product} {qty}Í∞ú\nÍµ¨Îß§ Í∞êÏÇ¨Ìï©ÎãàÎã§ ÌõÑÍ∏∞ ÏûëÏÑ± Î∂ÄÌÉÅÎìúÎ¶ΩÎãàÎã§:gift_heart:",
        color=GRAY
    ))

def emb_review_full(product: str, stars: int, content: str):
    line="„Ö°"*18
    return set_v2(discord.Embed(
        title="Íµ¨Îß§ ÌõÑÍ∏∞",
        description=f"**Íµ¨Îß§Ï†úÌíà** : {product}\n**Î≥ÑÏ†ê** : {'‚≠êÔ∏è'*max(1,min(stars,5))}\n{line}\n{content}\n{line}",
        color=GRAY
    ))

def emb_purchase_dm(product: str, qty: int, price: int, items: list[str]):
    line="„Ö°"*18
    vis=items[:20]
    rest=len(items)-len(vis)
    block="\n".join(vis)+ (f"\nÏô∏ {rest}Í∞ú‚Ä¶" if rest>0 else "")
    if not block: block="ÌëúÏãúÌï† Ìï≠Î™©Ïù¥ ÏóÜÏäµÎãàÎã§"
    return set_v2(discord.Embed(
        title="Íµ¨Îß§ ÏÑ±Í≥µ",
        description=f"Ï†úÌíà Ïù¥Î¶Ñ : {product}\nÍµ¨Îß§ Í∞úÏàò : {qty}\nÏ∞®Í∞ê Í∏àÏï° : {price}\n{line}\n{block}",
        color=GREEN
    ))

# ===== ÏûêÎèôÏ∂©Ï†Ñ(Í≥ÑÏ¢å) =====
TOPUP_TIMEOUT_SEC = 5*60
def expire_old_requests():
    now=_now(); changed=False
    for r in DB["topups"]["requests"]:
        if r.get("status","pending")=="pending" and now - int(r.get("ts",now)) > TOPUP_TIMEOUT_SEC:
            r["status"]="expired"; changed=True
    if changed: db_save()

def _hash_receipt(gid:int, amount:int, depositor:str):
    bucket=_now()//10
    base=f"{gid}|{amount}|{str(depositor).lower()}|{bucket}"
    return hashlib.sha256(base.encode("utf-8")).hexdigest()[:24]

async def handle_deposit(guild: discord.Guild, amount: int, depositor: str):
    expire_old_requests()
    key=_hash_receipt(guild.id, int(amount), str(depositor))
    if any(rc.get("hash")==key for rc in DB["topups"]["receipts"]):
        return False, "duplicate"
    now=_now()
    pending=[r for r in DB["topups"]["requests"]
             if r.get("status","pending")=="pending"
             and r.get("guildId")==guild.id
             and now - int(r.get("ts",now)) <= TOPUP_TIMEOUT_SEC
             and int(r.get("amount",0))==int(amount)]
    exact=[r for r in pending if str(r.get("depositor","")).strip().lower()==str(depositor).strip().lower()]
    exact.sort(key=lambda r:int(r.get("ts",0)), reverse=True)
    pending.sort(key=lambda r:int(r.get("ts",0)), reverse=True)
    target = exact[0] if exact else (pending[0] if pending else None)
    matched_user_id=None
    if target:
        matched_user_id=int(target["userId"])
        target["status"]="ok"
        bal_add(guild.id, matched_user_id, int(amount))
        db_save()
        try:
            user=guild.get_member(matched_user_id) or await guild.fetch_member(matched_user_id)
            dm=await user.create_dm()
            await dm.send(f"[ÏûêÎèôÏ∂©Ï†Ñ ÏôÑÎ£å]\nÍ∏àÏï°: {amount}Ïõê\nÏûÖÍ∏àÏûê: {depositor}")
        except: pass
    DB["topups"]["receipts"].append({
        "hash":key,"guildId":guild.id,"amount":int(amount),
        "depositor":str(depositor),"ts":_now(),"userId":matched_user_id
    }); db_save()
    return (True,"matched") if matched_user_id else (False,"queued")

# ===== Ïª¨Ï≥ê ÏÑ∏ÏÖò Ïø†ÌÇ§ Ï†ÄÏû•/Î≥µÏõê =====
CULTURE_K = os.getenv("CULTURE_K", "change_me")
def _enc(plain: str) -> str:
    return base64.b64encode((plain or "").encode()).decode()
def _dec(cipher: str) -> str:
    try: return base64.b64decode(cipher.encode()).decode()
    except: return ""

def _save_culture_cookies(gid:int, uid:int, cookies:list[dict]):
    DB["culture_accounts"].setdefault(str(gid), {}).setdefault(str(uid), {})
    DB["culture_accounts"][str(gid)][str(uid)]["cookies"] = cookies
    DB["culture_accounts"][str(gid)][str(uid)]["cookiesAt"] = _now()
    db_save()

async def _restore_culture_cookies(context, gid:int, uid:int):
    acc = DB["culture_accounts"].get(str(gid), {}).get(str(uid)) or {}
    cookies = acc.get("cookies") or []
    if cookies:
        try:
            await context.add_cookies(cookies)
            return True
        except:
            return False
    return False

def _cookies_expired(gid:int, uid:int, ttl_sec:int=60*60*12):
    acc = DB["culture_accounts"].get(str(gid), {}).get(str(uid)) or {}
    ts = int(acc.get("cookiesAt") or 0)
    return (_now() - ts) > ttl_sec

# ===== Ïª¨Ï≥êÎûúÎìú ÏûêÎèôÌôî(ÏÑ∏ÏÖò Ïö∞ÏÑ†+Î°úÍ∑∏ Í∏∞Î°ù) =====
async def culture_login_and_redeem(pin: str, gid:int, uid:int) -> tuple[bool, int, str]:
    if not PLAYWRIGHT_AVAILABLE:
        return False, 0, "ÏûêÎèôÌôî Î™®Îìà ÎØ∏ÏÑ§Ïπò(Playwright)."
    acc = DB["culture_accounts"].get(str(gid), {}).get(str(uid))
    if not acc:
        return False, 0, "Ïª¨Ï≥êÎûúÎìú Í≥ÑÏ†ï ÎØ∏Îì±Î°ù(/Ïª¨Ï≥êÎûúÎìú_ÏÑ§Ï†ï)"
    cid=_dec(acc.get("idEnc","")); cpw=_dec(acc.get("pwEnc",""))
    if not cid or not cpw:
        return False, 0, "Í≥ÑÏ†ï Î≥µÌò∏Ìôî Ïã§Ìå®"
    p = pin.replace("-", "").replace(" ", "")
    if not p.isdigit() or len(p) not in (16, 18, 20):
        return False, 0, "ÌïÄ ÌòïÏãù Ïò§Î•ò"

    from playwright.async_api import async_playwright, TimeoutError as PwTimeout

    LOGIN_URL = "https://m.cultureland.co.kr/mmb/loginMain.do?returnUrl="
    HOME_URL  = "https://m.cultureland.co.kr/main.do"
    CHARGE_18_URL = "https://m.cultureland.co.kr/csh/cshGiftCard.do"
    CHARGE_16_URL = "https://m.cultureland.co.kr/csh/cshGiftCulture.do"

    SEL_ID = "input[type='text'], input[name='userId']"
    SEL_PW = "input[type='password'], input[name='passwd']"
    SEL_LOGIN_BTN = "button:has-text('Î°úÍ∑∏Ïù∏'), .btnLogin"
    SEL_4 = "input[placeholder='4ÏûêÎ¶¨']"
    SEL_6 = "input[placeholder='6ÏûêÎ¶¨']"
    SEL_CHARGE_BTN = "button:has-text('Ï∂©Ï†ÑÌïòÍ∏∞')"

    AMOUNT_REGEX = re.compile(r"([0-9][0-9,]{2,})\s*Ïõê")
    ERROR_TEXTS = ["Ïù¥ÎØ∏ ÏÇ¨Ïö©", "ÏûòÎ™ªÎêú", "ÏÇ¨Ïö©Ìï† Ïàò ÏóÜÎäî", "Ï∂©Ï†Ñ Î∂àÍ∞Ä", "Ïû†Ïãú ÌõÑ Îã§Ïãú", "Ïù∏Ï¶ù Ïã§Ìå®", "ÌïúÎèÑ"]
    OK_TEXTS = ["Ï∂©Ï†ÑÏù¥ ÏôÑÎ£å", "Ï∂©Ï†ÑÎêòÏóàÏäµÎãàÎã§", "Ï∂©Ï†Ñ ÏôÑÎ£å"]

    launch_kwargs = dict(headless=True, args=["--no-sandbox", "--disable-dev-shm-usage"])

    async with async_playwright() as pw:
        browser = await pw.chromium.launch(**launch_kwargs)
        context = await browser.new_context(user_agent="Mozilla/5.0 (iPhone; CPU iPhone OS 15_0 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/15.0 Mobile/15E148 Safari/604.1")
        page = await context.new_page()
        login_fresh = False
        try:
            session_ok=False
            if not _cookies_expired(gid, uid):
                if await _restore_culture_cookies(context, gid, uid):
                    try:
                        await page.goto(HOME_URL, timeout=15000)
                        html = await page.content()
                        if ("Î°úÍ∑∏ÏïÑÏõÉ" in html) or ("ÎßàÏù¥ÌéòÏù¥ÏßÄ" in html) or ("ÎÇ¥ Ï†ïÎ≥¥" in html):
                            session_ok=True
                    except:
                        session_ok=False

            if not session_ok:
                await page.goto(LOGIN_URL, timeout=20000)
                id_el = await page.query_selector(SEL_ID) or (await page.query_selector_all("input"))[0]
                await id_el.fill(cid)
                pw_el = await page.query_selector(SEL_PW) or (await page.query_selector_all("input[type='password']"))[0]
                await pw_el.fill(cpw)
                btn = await page.query_selector(SEL_LOGIN_BTN) or await page.query_selector("button")
                await btn.click()
                await page.wait_for_timeout(1500)
                html = await page.content()
                if "hCaptcha" in html or "Ï∫°Ï∞®" in html:
                    return False, 0, "Ï∫°Ï∞® Ï∞®Îã®"
                if "ÎπÑÎ∞ÄÎ≤àÌò∏" in html and "Ïò§Î•ò" in html:
                    return False, 0, "Î°úÍ∑∏Ïù∏ Ïã§Ìå®"
                # Î°úÍ∑∏Ïù∏ ÏÑ±Í≥µ Î°úÍ∑∏
                await send_log_text(bot.get_guild(gid), "admin", f"[Ïª¨Ï≥êÎûúÎìú] Î°úÍ∑∏Ïù∏ ÏÑ±Í≥µ uid={uid}")
                try:
                    cookies = await context.cookies()
                    _save_culture_cookies(gid, uid, cookies)
                except:
                    pass
                login_fresh=True

            if len(p)==18:
                await page.goto(CHARGE_18_URL, timeout=20000)
                g1=p[0:4]; g2=p[4:8]; g3=p[8:12]; g4=p[12:16]; g5=p[16:22]
                boxes4 = await page.query_selector_all(SEL_4) or await page.query_selector_all("input[maxlength='4'], input[pattern='[0-9]{4}']")
                if len(boxes4)<4: return False, 0, "18ÏûêÎ¶¨ ÏûÖÎ†•Ïπ∏ Î∂ÄÏ°±"
                await boxes4[0].fill(g1); await boxes4[1].fill(g2); await boxes4[2].fill(g3); await boxes4[3].fill(g4)
                box6 = await page.query_selector(SEL_6) or await page.query_selector("input[maxlength='6']")
                if not box6: return False, 0, "18ÏûêÎ¶¨ 6Ïπ∏ ÏóÜÏùå"
                await box6.fill(g5)
            else:
                await page.goto(CHARGE_16_URL, timeout=20000)
                g1=p[0:4]; g2=p[4:8]; g3=p[8:12]; g4=p[12:16]
                boxes4 = await page.query_selector_all(SEL_4) or await page.query_selector_all("input[maxlength='4'], input[pattern='[0-9]{4}']")
                if len(boxes4)<4: return False, 0, "16ÏûêÎ¶¨ ÏûÖÎ†•Ïπ∏ Î∂ÄÏ°±"
                await boxes4[0].fill(g1); await boxes4[1].fill(g2); await boxes4[2].fill(g3); await boxes4[3].fill(g4)

            cbtn = await page.query_selector(SEL_CHARGE_BTN) or await page.query_selector("button:has-text('Ï∂©Ï†Ñ')")
            if not cbtn: return False, 0, "Ï∂©Ï†Ñ Î≤ÑÌäº ÏóÜÏùå"
            await cbtn.click()

            await page.wait_for_timeout(1500)
            html2 = await page.content()
            for fail in ERROR_TEXTS:
                if fail in html2:
                    return False, 0, f"Ï∂©Ï†Ñ Ïã§Ìå®: {fail}"

            amount=0
            m = re.search(r"([0-9][0-9,]{2,})\s*Ïõê", html2)
            if m:
                try: amount=int(m.group(1).replace(",",""))
                except: amount=0
            ok = any(t in html2 for t in OK_TEXTS)
            if ok and amount>0:
                return True, amount, ""

            await page.wait_for_timeout(900)
            html3 = await page.content()
            for fail in ERROR_TEXTS:
                if fail in html3:
                    return False, 0, f"Ï∂©Ï†Ñ Ïã§Ìå®: {fail}"
            m2 = re.search(r"([0-9][0-9,]{2,})\s*Ïõê", html3)
            if m2:
                try: amount=int(m2.group(1).replace(",",""))
                except: amount=0
            ok2 = any(t in html3 for t in OK_TEXTS)
            if ok2 and amount>0:
                return True, amount, ""
            return False, 0, "Í≤∞Í≥º ÌôïÏù∏ Ïã§Ìå®"
        except PwTimeout:
            return False, 0, "ÏùëÎãµ ÏßÄÏó∞"
        except NotImplementedError:
            return False, 0, "Ìò∏Ïä§Ìä∏Í∞Ä ÌïòÏúÑ ÌîÑÎ°úÏÑ∏Ïä§ ÎØ∏ÏßÄÏõê"
        except Exception as e:
            return False, 0, f"ÏûêÎèôÌôî ÏòàÏô∏: {str(e)[:120]}"
        finally:
            try:
                cookies = await context.cookies()
                _save_culture_cookies(gid, uid, cookies)
            except:
                pass
            with contextlib.suppress(Exception): await context.close()
            with contextlib.suppress(Exception): await browser.close()

# ===== ÌõÑÍ∏∞(1Ìöå Ï†úÌïú) =====
def can_send_review(gid:int, uid:int, unique_key:str) -> bool:
    DB["purchases_sent"].setdefault(str(gid), {}).setdefault(str(uid), {})
    return not DB["purchases_sent"][str(gid)][str(uid)].get(unique_key, False)

def lock_review(gid:int, uid:int, unique_key:str):
    DB["purchases_sent"].setdefault(str(gid), {}).setdefault(str(uid), {})
    DB["purchases_sent"][str(gid)][str(uid)][unique_key]=True
    db_save()

class ReviewSendModal(discord.ui.Modal, title="Íµ¨Îß§ ÌõÑÍ∏∞ ÏûëÏÑ±"):
    product_input = discord.ui.TextInput(label="Íµ¨Îß§ Ï†úÌíà", required=True, max_length=60)
    stars_input   = discord.ui.TextInput(label="Î≥ÑÏ†ê(1~5)", required=True, max_length=1)
    content_input = discord.ui.TextInput(label="ÌõÑÍ∏∞ ÎÇ¥Ïö©", style=discord.TextStyle.paragraph, required=True, max_length=500)
    def __init__(self, gid:int, uid:int, unique_key:str, default_product:str=""):
        super().__init__()
        self.gid=gid; self.uid=uid; self.unique_key=unique_key
        if default_product: self.product_input.default=default_product
    async def on_submit(self, it: discord.Interaction):
        if not can_send_review(self.gid, self.uid, self.unique_key):
            await it.response.send_message(embed=set_v2(discord.Embed(title="ÌõÑÍ∏∞ Ï†ÑÏÜ° Î∂àÍ∞Ä", description="Ïù¥ÎØ∏ ÏûëÏÑ±Îê®", color=PINK)), ephemeral=True); return
        s=str(self.stars_input.value).strip()
        if not s.isdigit() or not (1<=int(s)<=5):
            await it.response.send_message("Î≥ÑÏ†êÏùÄ 1~5 Ïà´Ïûê", ephemeral=True); return
        product=str(self.product_input.value).strip()
        content=str(self.content_input.value).strip()
        e = emb_review_full(product, int(s), content)
        guild = it.guild or bot.get_guild(GUILD_ID)
        if guild: await send_log_embed(guild, "review", e)
        lock_review(self.gid, self.uid, self.unique_key)
        await it.response.send_message("ÌõÑÍ∏∞ Ï†ÑÏÜ° ÏôÑÎ£å", ephemeral=True)

class ReviewButtonView(discord.ui.View):
    def __init__(self, gid:int, uid:int, unique_key:str, default_product:str=""):
        super().__init__(timeout=None)
        btn = discord.ui.Button(label=f"{EMJ_HEART} ÌõÑÍ∏∞ Ï†ÑÏÜ°", style=discord.ButtonStyle.secondary)
        async def _cb(i:discord.Interaction):
            if i.user.id!=uid:
                await i.response.send_message("Íµ¨Îß§ÏûêÎßå Í∞ÄÎä•", ephemeral=True); return
            if not can_send_review(gid, uid, unique_key):
                await i.response.send_message("Ïù¥ÎØ∏ ÏûëÏÑ±Îê®", ephemeral=True); return
            await i.response.send_modal(ReviewSendModal(gid, uid, unique_key, default_product))
        btn.callback=_cb
        self.add_item(btn)

# ===== Ï∂©Ï†Ñ(Í≥ÑÏ¢å ÏäπÏù∏/Í±∞Î∂Ä) =====
class SecureApproveView(discord.ui.View):
    def __init__(self, payload: dict):
        super().__init__(timeout=TOPUP_TIMEOUT_SEC)
        b_ok=discord.ui.Button(label="ÏäπÏù∏", style=discord.ButtonStyle.success, emoji=safe_emoji(EMJ_APPROVE))
        b_no=discord.ui.Button(label="Í±∞Î∂Ä", style=discord.ButtonStyle.danger,  emoji=safe_emoji(EMJ_DECLINE))
        async def _ok(i:discord.Interaction):
            await notify_user_topup_result(i.client, payload, True)
            await i.response.edit_message(embed=set_v2(discord.Embed(title="ÏäπÏù∏ ÏôÑÎ£å", description="Ìï¥Îãπ Ï∂©Ï†ÑÏã†Ï≤≠ÏùÑ ÏäπÏù∏ÌñàÏäµÎãàÎã§.", color=GREEN)), view=None)
        async def _no(i:discord.Interaction):
            await notify_user_topup_result(i.client, payload, False)
            await i.response.edit_message(embed=set_v2(discord.Embed(title="Í±∞Î∂Ä ÏôÑÎ£å", description="Ìï¥Îãπ Ï∂©Ï†ÑÏã†Ï≤≠ÏùÑ Í±∞Î∂ÄÌñàÏäµÎãàÎã§.", color=RED)), view=None)
        b_ok.callback=_ok; b_no.callback=_no
        self.add_item(b_ok); self.add_item(b_no)

async def notify_user_topup_result(client: discord.Client, payload: dict, approved: bool):
    gid=int(payload["guild_id"]); uid=int(payload["user_id"])
    guild = client.get_guild(gid)
    if not guild: return
    try:
        user = guild.get_member(uid) or await guild.fetch_member(uid)
        e=set_v2(discord.Embed(
            title=("Ï∂©Ï†ÑÏôÑÎ£å" if approved else "Ï∂©Ï†ÑÏã§Ìå®"),
            description=("Ï∂©Ï†ÑÏã†Ï≤≠Ïù¥ ÏÑ±Í≥µÏ†ÅÏúºÎ°ú ÏôÑÎ£åÎêòÏóàÏäµÎãàÎã§" if approved else "Ï∂©Ï†ÑÏã†Ï≤≠Ïù¥ Í±∞Î∂ÄÎêòÏóàÏäµÎãàÎã§"),
            color=(GREEN if approved else RED)
        ))
        dm=await user.create_dm()
        await dm.send(embed=e)
    except: pass

class PaymentModal(discord.ui.Modal, title="Ï∂©Ï†Ñ Ïã†Ï≤≠"):
    amount_input = discord.ui.TextInput(label="Ï∂©Ï†ÑÌï† Í∏àÏï°", required=True, max_length=12)
    depositor_input = discord.ui.TextInput(label="ÏûÖÍ∏àÏûêÎ™Ö", required=True, max_length=20)
    def __init__(self, owner_id:int):
        super().__init__(); self.owner_id=owner_id
    async def on_submit(self, it: discord.Interaction):
        try:
            amt_raw=str(self.amount_input.value).strip().replace(",","")
            amt=int(amt_raw) if amt_raw.isdigit() else 0
            depos=str(self.depositor_input.value).strip()
            if amt>0 and depos:
                DB["topups"]["requests"].append({
                    "guildId": it.guild.id, "userId": it.user.id,
                    "amount": amt, "depositor": depos, "ts": _now(), "status": "pending"
                }); db_save()
        except: pass
        bank=DB["account"].get("bank","ÎØ∏Îì±Î°ù")
        holder=DB["account"].get("holder","ÎØ∏Îì±Î°ù")
        number=DB["account"].get("number","ÎØ∏Îì±Î°ù")
        amount_txt=f"{amt_raw}Ïõê" if amt_raw else "0Ïõê"
        e_user=set_v2(discord.Embed(
            title="Ï∂©Ï†ÑÏã†Ï≤≠",
            description=f"ÏùÄÌñâÎ™Ö : {bank}\nÏòàÍ∏àÏ£º : {holder}\nÍ≥ÑÏ¢åÎ≤àÌò∏ : `{number}`\nÎ≥¥ÎÇ¥ÏïºÌï† Í∏àÏï° : {amount_txt}",
            color=GREEN
        ))
        await it.response.send_message(embed=e_user, ephemeral=True)
        secure_ch=get_log_channel(it.guild, "secure")
        if secure_ch:
            payload={"guild_id":it.guild.id,"user_id":it.user.id,"amount":amt,"amount_txt":amount_txt,"depositor":depos}
            e_sec=set_v2(discord.Embed(
                title="Ï∂©Ï†ÑÏïåÎ¶º",
                description=f"Ïú†Ï†Ä : {it.user.mention}\nÏ∂©Ï†Ñ Í∏àÏï° : {amount_txt}\nÏûÖÍ∏àÏûêÎ™Ö : {depos}",
                color=ORANGE
            ))
            await secure_ch.send(embed=e_sec, view=SecureApproveView(payload))

# ===== Ïª¨Ï≥ê ÏÑ§Ï†ï/Î™®Îã¨ =====
class CultureAccountModal(discord.ui.Modal, title="Ïª¨Ï≥êÎûúÎìú ÏÑ§Ï†ï"):
    id_input = discord.ui.TextInput(label="ID", required=True, max_length=60)
    pw_input = discord.ui.TextInput(label="PW", required=True, max_length=80)
    opt_input= discord.ui.TextInput(label="ÏòµÏÖò(ÏÑ†ÌÉù)", required=False, max_length=50)
    def __init__(self, owner_id:int):
        super().__init__(); self.owner_id=owner_id
    async def on_submit(self, it: discord.Interaction):
        if it.user.id != self.owner_id:
            await it.response.send_message("ÏûëÏÑ±ÏûêÎßå ÏÑ§Ï†ï Í∞ÄÎä•", ephemeral=True); return
        gid=str(it.guild.id); uid=str(it.user.id)
        DB["culture_accounts"].setdefault(gid, {})
        DB["culture_accounts"][gid][uid] = {
            "idEnc": _enc(str(self.id_input.value).strip()),
            "pwEnc": _enc(str(self.pw_input.value).strip()),
            "options": str(self.opt_input.value).strip(),
            "cookies": DB["culture_accounts"].get(gid, {}).get(uid, {}).get("cookies", []),
            "cookiesAt": DB["culture_accounts"].get(gid, {}).get(uid, {}).get("cookiesAt", 0),
            "createdAt": _now(),
            "updatedAt": _now()
        }
        db_save()
        await it.response.send_message(embed=set_v2(discord.Embed(title="Ïª¨Ï≥êÎûúÎìú Í≥ÑÏ†ï Ï†ÄÏû• ÏôÑÎ£å", description="Î¨∏ÏÉÅÍ≤∞Ï†úÏóêÏÑú ÏûêÎèô ÏÇ¨Ïö©Îê©ÎãàÎã§.", color=GRAY)), ephemeral=True)

class CulturePinModal(discord.ui.Modal, title="Î¨∏ÌôîÏÉÅÌíàÍ∂å Ï∂©Ï†Ñ(Ïª¨Ï≥êÎûúÎìú)"):
    pin_input = discord.ui.TextInput(label="ÌïÄÏΩîÎìú(ÌïòÏù¥Ìîà ÏóÜÏù¥)", required=True, max_length=32)
    def __init__(self, owner_id:int):
        super().__init__(); self.owner_id=owner_id
    async def on_submit(self, it: discord.Interaction):
        pin = str(self.pin_input.value).strip()
        ok, amount, reason = await culture_login_and_redeem(pin, it.guild.id, it.user.id)
        if not ok or amount <= 0:
            await it.response.send_message(embed=set_v2(discord.Embed(title="Ï∂©Ï†ÑÏã§Ìå®", description=reason or "Í≤ÄÏ¶ù Ïã§Ìå®", color=RED)), ephemeral=True); return
        res_ok, _ = await handle_deposit(it.guild, int(amount), "Î¨∏ÌôîÏÉÅÌíàÍ∂å(Ïª¨Ï≥êÎûúÎìú)")
        if res_ok:
            await it.response.send_message(embed=set_v2(discord.Embed(title="Ï∂©Ï†ÑÏôÑÎ£å", description=f"{amount}Ïõê Ï∂©Ï†ÑÎêòÏóàÏäµÎãàÎã§", color=GREEN)), ephemeral=True)
        else:
            await it.response.send_message(embed=set_v2(discord.Embed(title="Ï∂©Ï†ÑÎåÄÍ∏∞", description="Ïû†Ïãú ÌõÑ Î∞òÏòÅÎê©ÎãàÎã§.", color=ORANGE)), ephemeral=True)

# ===== Í≤∞Ï†úÏàòÎã® Î∑∞ =====
class PaymentMethodView(discord.ui.View):
    def __init__(self):
        super().__init__(timeout=None)
        btns=[]
        if DB["payments"].get("bank", False):
            btns.append(discord.ui.Button(label="Í≥ÑÏ¢åÏù¥Ï≤¥", style=discord.ButtonStyle.secondary, emoji=safe_emoji(EMJ_TOSS)))
        if DB["payments"].get("culture", False):
            btns.append(discord.ui.Button(label="Î¨∏ÏÉÅÍ≤∞Ï†ú", style=discord.ButtonStyle.secondary, emoji=safe_emoji(EMJ_CULTURE)))
        if DB["payments"].get("coin", False):
            btns.append(discord.ui.Button(label="ÏΩîÏù∏Í≤∞Ï†ú", style=discord.ButtonStyle.secondary, emoji=safe_emoji(EMJ_COIN)))
        for b in btns:
            async def _cb(i:discord.Interaction, label=b.label):
                if label=="Í≥ÑÏ¢åÏù¥Ï≤¥":
                    await i.response.send_modal(PaymentModal(i.user.id))
                elif label=="Î¨∏ÏÉÅÍ≤∞Ï†ú":
                    if not PLAYWRIGHT_AVAILABLE:
                        await i.response.send_message("ÏûêÎèôÌôî Î™®Îìà ÎØ∏ÏÑ§Ïπò(Playwright).", ephemeral=True); return
                    await i.response.send_modal(CulturePinModal(i.user.id))
                else:
                    await i.response.send_message(embed=set_v2(discord.Embed(title="Ïã§Ìå®", description="ÌòÑÏû¨ ÎØ∏ÏßÄÏõê", color=RED)), ephemeral=True)
            b.callback=_cb
            self.add_item(b)

# ===== Ïπ¥ÌÖåÍ≥†Î¶¨/Ï†úÌíà(ÏòàÏ†Ñ ÌîåÎ°úÏö∞) =====
def build_category_embed():
    lines=[]
    if DB["categories"]:
        for c in DB["categories"]:
            prod_count = len([p for p in DB["products"] if p["category"]==c["name"]])
            stars=category_avg_stars(c["name"])
            lines.append(f"**Ïπ¥ÌÖåÍ≥†Î¶¨Î™Ö : {c['name']}**")
            lines.append(f"-# Ï†úÌíà : {prod_count}")
            lines.append(f"-# Î≥ÑÏ†ê : {stars}")
            lines.append("„Ö°"*18)
    else:
        lines.append("Îì±Î°ùÎêú Ïπ¥ÌÖåÍ≥†Î¶¨Í∞Ä ÏóÜÏäµÎãàÎã§")
    return set_v2(discord.Embed(title="Ïπ¥ÌÖåÍ≥†Î¶¨Î•º ÏÑ†ÌÉùÌï¥Ï£ºÏÑ∏Ïöî", description="\n".join(lines), color=GRAY))

class QuantityModal(discord.ui.Modal, title="ÏàòÎüâ ÏûÖÎ†•"):
    qty_input = discord.ui.TextInput(label="Íµ¨Îß§ ÏàòÎüâ", required=True, max_length=6)
    def __init__(self, owner_id:int, category:str, product_name:str):
        super().__init__(); self.owner_id=owner_id; self.category=category; self.product_name=product_name
    async def on_submit(self, it: discord.Interaction):
        if it.user.id!=self.owner_id:
            await it.response.send_message("ÏûëÏÑ±ÏûêÎßå ÏÇ¨Ïö© Í∞ÄÎä•", ephemeral=True); return
        s=str(self.qty_input.value).strip()
        if not s.isdigit() or int(s)<=0:
            await it.response.send_message("ÏàòÎüâÏùÄ 1 Ïù¥ÏÉÅÏùò Ïà´Ïûê", ephemeral=True); return
        qty=int(s); p=prod_get(self.product_name, self.category)
        if not p:
            await it.response.send_message("Ïú†Ìö®ÌïòÏßÄ ÏïäÏùÄ Ï†úÌíà", ephemeral=True); return
        if p["stock"]<qty:
            await it.response.send_message(embed=set_v2(discord.Embed(title="Ïû¨Í≥† Î∂ÄÏ°±", description=f"{self.product_name} Ïû¨Í≥†Í∞Ä Î∂ÄÏ°±Ìï©ÎãàÎã§.", color=ORANGE)), ephemeral=True); return
        taken=[]; cnt=qty
        while cnt>0 and p["items"]:
            taken.append(p["items"].pop(0)); cnt-=1
        p["stock"]-=qty; p["sold_count"]+=qty; db_save()
        bal_sub(it.guild.id, it.user.id, p["price"]*qty)
        try:
            dm=await it.user.create_dm()
            unique_key=f"{it.guild.id}:{it.user.id}:{self.product_name}:{_now()}"
            await dm.send(embed=emb_purchase_dm(self.product_name, qty, p["price"], taken), view=ReviewButtonView(it.guild.id, it.user.id, unique_key, self.product_name))
        except: pass
        try:
            await send_log_embed(it.guild, "purchase", emb_purchase_log(it.user, self.product_name, qty))
        except: pass
        await it.response.send_message(embed=set_v2(discord.Embed(title="Íµ¨Îß§ ÏôÑÎ£å", description=f"{self.product_name} Íµ¨Îß§Í∞Ä ÏôÑÎ£åÎêòÏóàÏäµÎãàÎã§. DMÏùÑ ÌôïÏù∏Ìï¥Ï£ºÏÑ∏Ïöî.", color=GREEN)), ephemeral=True)

class ProductSelect(discord.ui.Select):
    def __init__(self, owner_id:int, category:str):
        prods=prod_list_by_cat(category)
        opts=[]
        if prods:
            for p in prods[:25]:
                opts.append(discord.SelectOption(label=p["name"], value=p["name"], description=f"Í∞ÄÍ≤© {p['price']}"))
        else:
            opts=[discord.SelectOption(label="Ìï¥Îãπ Ïπ¥ÌÖåÍ≥†Î¶¨Ïóê Ï†úÌíàÏù¥ ÏóÜÏäµÎãàÎã§", value="__none__")]
        super().__init__(placeholder="Ï†úÌíàÏùÑ ÏÑ†ÌÉùÌïòÏÑ∏Ïöî", min_values=1, max_values=1, options=opts, custom_id=f"prod_sel_{owner_id}")
        self.owner_id=owner_id; self.category=category
    async def callback(self, it: discord.Interaction):
        if it.user.id!=self.owner_id:
            await it.response.send_message("ÏûëÏÑ±ÏûêÎßå ÏÇ¨Ïö© Í∞ÄÎä•", ephemeral=True); return
        val=self.values[0]
        if val=="__none__":
            await it.response.send_message("Î®ºÏ†Ä Ï†úÌíàÏùÑ Ï∂îÍ∞ÄÌï¥Ï£ºÏÑ∏Ïöî.", ephemeral=True); return
        await it.response.send_modal(QuantityModal(self.owner_id, self.category, val))

class CategorySelectForBuy(discord.ui.Select):
    def __init__(self, owner_id:int):
        cats=DB["categories"]
        if cats:
            opts=[discord.SelectOption(label=c["name"], value=c["name"], description=(c.get("desc")[:80] if c.get("desc") else None)) for c in cats[:25]]
        else:
            opts=[discord.SelectOption(label="Îì±Î°ùÎêú Ïπ¥ÌÖåÍ≥†Î¶¨Í∞Ä ÏóÜÏäµÎãàÎã§", value="__none__")]
        super().__init__(placeholder="Ïπ¥ÌÖåÍ≥†Î¶¨Î•º ÏÑ†ÌÉùÌïòÏÑ∏Ïöî", min_values=1, max_values=1, options=opts, custom_id=f"cat_buy_{owner_id}")
        self.owner_id=owner_id
    async def callback(self, it: discord.Interaction):
        if it.user.id!=self.owner_id:
            await it.response.send_message("ÏûëÏÑ±ÏûêÎßå ÏÇ¨Ïö© Í∞ÄÎä•", ephemeral=True); return
        val=self.values[0]
        if val=="__none__":
            await it.response.send_message("Î®ºÏ†Ä Ïπ¥ÌÖåÍ≥†Î¶¨Î•º Ï∂îÍ∞ÄÌï¥Ï£ºÏÑ∏Ïöî.", ephemeral=True); return
        e=set_v2(discord.Embed(title="Ï†úÌíà ÏÑ†ÌÉùÌïòÍ∏∞", description="Ï†úÌíàÏùÑ ÏÑ†ÌÉùÌï¥Ï£ºÏÑ∏Ïöî", color=GRAY))
        v=discord.ui.View(timeout=None); v.add_item(ProductSelect(self.owner_id, val))
        await it.response.send_message(embed=e, view=v, ephemeral=True)

class CategorySelectForBuyView(discord.ui.View):
    def __init__(self, owner_id:int):
        super().__init__(timeout=None); self.add_item(CategorySelectForBuy(owner_id))

# ===== Î≤ÑÌäº Ìå®ÎÑê =====
class ButtonPanel(discord.ui.View):
    def __init__(self):
        super().__init__(timeout=None)
        n=discord.ui.Button(label="Í≥µÏßÄÏÇ¨Ìï≠", style=discord.ButtonStyle.secondary, emoji=safe_emoji(EMJ_NOTICE), row=0)
        c=discord.ui.Button(label="Ï∂©Ï†Ñ",   style=discord.ButtonStyle.secondary, emoji=safe_emoji(EMJ_CHARGE), row=0)
        i=discord.ui.Button(label="ÎÇ¥ Ï†ïÎ≥¥", style=discord.ButtonStyle.secondary, emoji=safe_emoji(EMJ_INFO),   row=1)
        b=discord.ui.Button(label="Íµ¨Îß§",   style=discord.ButtonStyle.secondary, emoji=safe_emoji(EMJ_BUY),    row=1)
        async def _notice(it):
            await it.response.send_message(embed=set_v2(discord.Embed(title="Í≥µÏßÄÏÇ¨Ìï≠", description="ÏÑúÎ≤ÑÍ∑úÏπô ÌïÑÎèÖ Î∂ÄÌÉÅÎìúÎ¶ΩÎãàÎã§\nÏûêÏ∂© Ïò§Î•òÏãú Ìã∞Ïºì Ïó¥Ïñ¥Ï£ºÏÑ∏Ïöî", color=GRAY)), ephemeral=True)
        async def _charge(it):
            if ban_is_blocked(it.guild.id, it.user.id):
                await it.response.send_message(embed=set_v2(discord.Embed(title="Ïù¥Ïö© Î∂àÍ∞Ä", description="Ï∞®Îã® ÏÉÅÌÉúÏûÖÎãàÎã§. /Ïú†Ï†Ä_ÏÑ§Ï†ïÏúºÎ°ú Ìï¥Ï†úÌïòÏÑ∏Ïöî.", color=RED)), ephemeral=True); return
            view=PaymentMethodView()
            if len(view.children)==0:
                await it.response.send_message(embed=set_v2(discord.Embed(title="Í≤∞Ï†úÏàòÎã® ÏÑ†ÌÉùÌïòÍ∏∞", description="ÌòÑÏû¨ ÏßÄÏõêÎêòÎäî Í≤∞Ï†úÏàòÎã®Ïù¥ ÏóÜÏäµÎãàÎã§.", color=ORANGE)), ephemeral=True)
            else:
                await it.response.send_message(embed=set_v2(discord.Embed(title="Í≤∞Ï†úÏàòÎã® ÏÑ†ÌÉùÌïòÍ∏∞", description="ÏõêÌïòÏãúÎäî Í≤∞Ï†úÏàòÎã® Î≤ÑÌäºÏùÑ ÌÅ¥Î¶≠Ìï¥Ï£ºÏÑ∏Ïöî", color=GRAY)), view=view, ephemeral=True)
        async def _info(it):
            gid=it.guild.id; uid=it.user.id
            ords=orders_get(gid, uid); spent=0
            for o in ords:
                p=next((pp for pp in DB["products"] if pp["name"]==o["product"]), None)
                if p: spent += p["price"]*o["qty"]
            bal=bal_get(gid, uid); pts=pt_get(gid, uid)
            line="„Ö°"*18
            desc=f"Î≥¥Ïú† Í∏àÏï° : {bal}\nÎàÑÏ†Å Í∏àÏï° : {spent}\nÌè¨Ïù∏Ìä∏ : {pts}\nÍ±∞Îûò ÌöüÏàò : {len(ords)}\n{line}\nÏó≠Ìï†Îì±Í∏â : ÏïÑÏßÅ ÏóÜÏäµÎãàÎã§\nÏó≠Ìï†ÌòúÌÉù : ÏïÑÏßÅ ÏóÜÏäµÎãàÎã§"
            e=set_v2(discord.Embed(title="ÎÇ¥ Ï†ïÎ≥¥", description=desc, color=GRAY))
            try: e.set_thumbnail(url=it.user.display_avatar.url)
            except: pass
            await it.response.send_message(embed=e, view=MyInfoView(uid, ords), ephemeral=True)
        async def _buy(it):
            if ban_is_blocked(it.guild.id, it.user.id):
                await it.response.send_message(embed=set_v2(discord.Embed(title="Ïù¥Ïö© Î∂àÍ∞Ä", description="Ï∞®Îã® ÏÉÅÌÉúÏûÖÎãàÎã§. /Ïú†Ï†Ä_ÏÑ§Ï†ïÏúºÎ°ú Ìï¥Ï†úÌïòÏÑ∏Ïöî.", color=RED)), ephemeral=True); return
            e = build_category_embed()
            v = CategorySelectForBuyView(it.user.id)
            await it.response.send_message(embed=e, view=v, ephemeral=True)
        n.callback=_notice; c.callback=_charge; i.callback=_info; b.callback=_buy
        self.add_item(n); self.add_item(c); self.add_item(i); self.add_item(b)

# ===== ÎÇ¥ Ï†ïÎ≥¥ =====
class RecentOrdersSelect(discord.ui.Select):
    def __init__(self, owner_id:int, orders:list[dict]):
        opts=[]
        for o in orders[-5:][::-1]:
            ts=time.strftime('%Y-%m-%d %H:%M', time.localtime(o['ts']))
            opts.append(discord.SelectOption(label=f"{o['product']} x{o['qty']}", description=ts, value=f"{o['product']}||{o['qty']}||{o['ts']}"))
        if not opts:
            opts=[discord.SelectOption(label="ÏµúÍ∑º Íµ¨Îß§ ÏóÜÏùå", value="__none__", description="ÌëúÏãúÌï† Ìï≠Î™©Ïù¥ ÏóÜÏäµÎãàÎã§")]
        super().__init__(placeholder="ÏµúÍ∑º Íµ¨Îß§ ÎÇ¥Ïó≠ Î≥¥Í∏∞", min_values=1, max_values=1, options=opts, custom_id=f"recent_{owner_id}")
        self.owner_id=owner_id
    async def callback(self, it: discord.Interaction):
        if it.user.id!=self.owner_id:
            await it.response.send_message("ÏûëÏÑ±ÏûêÎßå Î≥º Ïàò ÏûàÏñ¥.", ephemeral=True); return
        val=self.values[0]
        if val=="__none__":
            await it.response.send_message("ÏµúÍ∑º Íµ¨Îß§Í∞Ä ÏóÜÏäµÎãàÎã§.", ephemeral=True); return
        name, qty, ts = val.split("||")
        ts_str=time.strftime('%Y-%m-%d %H:%M', time.localtime(int(ts)))
        await it.response.send_message(embed=set_v2(discord.Embed(title="Íµ¨Îß§ ÏÉÅÏÑ∏", description=f"- Ï†úÌíà: {name}\n- ÏàòÎüâ: {qty}\n- ÏãúÍ∞Ñ: {ts_str}", color=GRAY)), ephemeral=True)

class MyInfoView(discord.ui.View):
    def __init__(self, owner_id:int, orders:list[dict]):
        super().__init__(timeout=None); self.add_item(RecentOrdersSelect(owner_id, orders))

# ===== Í¥ÄÎ¶¨Ïûê Î≥¥Ìò∏ =====
def is_admin():
    async def predicate(interaction: discord.Interaction):
        if interaction.user.guild_permissions.manage_guild:
            return True
        await interaction.response.send_message("Í¥ÄÎ¶¨ÏûêÎßå ÏÇ¨Ïö©Ìï† Ïàò ÏûàÏñ¥.", ephemeral=True)
        return False
    return app_commands.check(predicate)

# ===== Ïä¨ÎûòÏãú Î™ÖÎ†πÏñ¥(11Í∞ú) =====
class CategoryDeleteView(discord.ui.View):
    def __init__(self, owner_id:int):
        super().__init__(timeout=None)
        class CategoryDeleteSelect(discord.ui.Select):
            def __init__(self, owner_id:int):
                cats=DB["categories"]; opts=[]
                for c in cats[:25]:
                    opts.append(discord.SelectOption(label=c["name"], value=c["name"], description=(c.get("desc")[:80] if c.get("desc") else None)))
                super().__init__(placeholder="ÏÇ≠Ï†úÌï† Ïπ¥ÌÖåÍ≥†Î¶¨Î•º ÏÑ†ÌÉùÌïòÏÑ∏Ïöî", min_values=1, max_values=1, options=opts or [discord.SelectOption(label="ÏÇ≠Ï†úÌï† Ïπ¥ÌÖåÍ≥†Î¶¨Í∞Ä ÏóÜÏäµÎãàÎã§", value="__none__")], custom_id=f"cat_del_{owner_id}")
                self.owner_id=owner_id
            async def callback(self, it: discord.Interaction):
                if it.user.id!=self.owner_id:
                    await it.response.send_message("ÏûëÏÑ±ÏûêÎßå ÏÑ†ÌÉù Í∞ÄÎä•", ephemeral=True); return
                val=self.values[0]
                if val=="__none__":
                    await it.response.send_message("ÏÇ≠Ï†úÌï† Ïπ¥ÌÖåÍ≥†Î¶¨Í∞Ä ÏóÜÏäµÎãàÎã§.", ephemeral=True); return
                DB["categories"]=[c for c in DB["categories"] if c["name"]!=val]
                DB["products"]=[p for p in DB["products"] if p["category"]!=val]; db_save()
                await it.response.send_message(embed=set_v2(discord.Embed(title="Ïπ¥ÌÖåÍ≥†Î¶¨ ÏÇ≠Ï†ú ÏôÑÎ£å", description=f"ÏÇ≠Ï†úÎêú Ïπ¥ÌÖåÍ≥†Î¶¨: {val}", color=GRAY)), ephemeral=True)
        self.add_item(CategoryDeleteSelect(owner_id))

class CategorySetupModal(discord.ui.Modal, title="Ïπ¥ÌÖåÍ≥†Î¶¨ Ï∂îÍ∞Ä"):
    name_input = discord.ui.TextInput(label="Ïπ¥ÌÖåÍ≥†Î¶¨ Ïù¥Î¶Ñ", required=True, max_length=60)
    desc_input = discord.ui.TextInput(label="Ïπ¥ÌÖåÍ≥†Î¶¨ ÏÑ§Î™Ö", style=discord.TextStyle.paragraph, required=False, max_length=200)
    emoji_input= discord.ui.TextInput(label="Ïπ¥ÌÖåÍ≥†Î¶¨ Ïù¥Î™®ÏßÄ", required=False, max_length=100)
    def __init__(self, owner_id:int):
        super().__init__(); self.owner_id=owner_id
    async def on_submit(self, it: discord.Interaction):
        if it.user.id!=self.owner_id:
            await it.response.send_message("ÏûëÏÑ±ÏûêÎßå ÏÇ¨Ïö© Í∞ÄÎä•", ephemeral=True); return
        name=str(self.name_input.value).strip()
        desc=str(self.desc_input.value).strip() if self.desc_input.value else ""
        emoji=str(self.emoji_input.value).strip() if self.emoji_input.value else ""
        i=next((k for k,c in enumerate(DB["categories"]) if c["name"]==name), -1)
        row={"name":name,"desc":desc,"emoji_raw":emoji}
        if i>=0: DB["categories"][i]=row
        else: DB["categories"].append(row)
        db_save()
        await it.response.send_message(embed=set_v2(discord.Embed(title="Ïπ¥ÌÖåÍ≥†Î¶¨ Îì±Î°ù ÏôÑÎ£å", description=f"{name}\n{desc}", color=GRAY)), ephemeral=True)

class StockAddModal(discord.ui.Modal, title="Ïû¨Í≥† Ï∂îÍ∞Ä"):
    lines_input = discord.ui.TextInput(label="Ïû¨Í≥† Ï∂îÍ∞Ä(Ï§ÑÎßàÎã§ 1Í∞ú)", style=discord.TextStyle.paragraph, required=True, max_length=4000)
    def __init__(self, owner_id:int, name:str, category:str):
        super().__init__(); self.owner_id=owner_id; self.name=name; self.category=category
    async def on_submit(self, it: discord.Interaction):
        if it.user.id!=self.owner_id:
            await it.response.send_message("ÏûëÏÑ±ÏûêÎßå ÏÇ¨Ïö© Í∞ÄÎä•", ephemeral=True); return
        lines=[ln.strip() for ln in str(self.lines_input.value).splitlines() if ln.strip()]
        p=prod_get(self.name, self.category)
        if not p:
            await it.response.send_message("Ïú†Ìö®ÌïòÏßÄ ÏïäÏùÄ Ï†úÌíàÏûÖÎãàÎã§.", ephemeral=True); return
        p["items"].extend(lines); p["stock"]+=len(lines); db_save()
        await it.response.send_message(embed=set_v2(discord.Embed(title="Ïû¨Í≥† Ï∂îÍ∞Ä ÏôÑÎ£å", description=f"{self.name} +{len(lines)} ‚Üí Ïû¨Í≥† {p['stock']}", color=GRAY)), ephemeral=True)

class ProductSetupModal(discord.ui.Modal, title="Ï†úÌíà Ï∂îÍ∞Ä"):
    name_input = discord.ui.TextInput(label="Ï†úÌíà Ïù¥Î¶Ñ", required=True, max_length=60)
    category_input = discord.ui.TextInput(label="Ïπ¥ÌÖåÍ≥†Î¶¨ Ïù¥Î¶Ñ", required=True, max_length=60)
    price_input = discord.ui.TextInput(label="Ï†úÌíà Í∞ÄÍ≤©(Ïõê)", required=True, max_length=10)
    emoji_input = discord.ui.TextInput(label="Ï†úÌíà Ïù¥Î™®ÏßÄ", required=False, max_length=100)
    desc_input  = discord.ui.TextInput(label="Ï†úÌíà ÏÑ§Î™Ö", style=discord.TextStyle.paragraph, required=False, max_length=400)
    def __init__(self, owner_id:int):
        super().__init__(); self.owner_id=owner_id
    async def on_submit(self, it: discord.Interaction):
        if it.user.id!=self.owner_id:
            await it.response.send_message("ÏûëÏÑ±ÏûêÎßå ÏÇ¨Ïö© Í∞ÄÎä•", ephemeral=True); return
        name=str(self.name_input.value).strip()
        cat=str(self.category_input.value).strip()
        price_s=str(self.price_input.value).strip()
        if not any(c["name"]==cat for c in DB["categories"]):
            await it.response.send_message("Ìï¥Îãπ Ïπ¥ÌÖåÍ≥†Î¶¨Í∞Ä ÏóÜÏäµÎãàÎã§.", ephemeral=True); return
        if not price_s.isdigit():
            await it.response.send_message("Í∞ÄÍ≤©ÏùÄ Ïà´ÏûêÎßå ÏûÖÎ†•", ephemeral=True); return
        price=int(price_s)
        emoji=str(self.emoji_input.value).strip() if self.emoji_input.value else ""
        desc=str(self.desc_input.value).strip() if self.desc_input.value else ""
        prod_upsert(name, cat, price, emoji, desc)
        await it.response.send_message(embed=set_v2(discord.Embed(title="Ï†úÌíà Îì±Î°ù ÏôÑÎ£å", description=f"{name}\nÏπ¥ÌÖåÍ≥†Î¶¨: {cat}\nÍ∞ÄÍ≤©: {price}\n(ÏÑ§Î™Ö Ï†ÄÏû•Îê®)", color=GRAY)), ephemeral=True)

class ProductDeleteView(discord.ui.View):
    def __init__(self, owner_id:int):
        super().__init__(timeout=None)
        class ProductDeleteSelect(discord.ui.Select):
            def __init__(self, owner_id:int):
                ps=prod_list_all(); opts=[]
                for p in ps[:25]:
                    opts.append(discord.SelectOption(label=p["name"], value=f"{p['name']}||{p['category']}", description=f"{p['category']}"))
                super().__init__(placeholder="ÏÇ≠Ï†úÌï† Ï†úÌíàÏùÑ ÏÑ†ÌÉù", min_values=1, max_values=1, options=opts or [discord.SelectOption(label="ÏÇ≠Ï†úÌï† Ï†úÌíàÏù¥ ÏóÜÏäµÎãàÎã§", value="__none__")], custom_id=f"prod_del_{owner_id}")
                self.owner_id=owner_id
            async def callback(self, it: discord.Interaction):
                if it.user.id!=self.owner_id:
                    await it.response.send_message("ÏûëÏÑ±ÏûêÎßå ÏÇ¨Ïö© Í∞ÄÎä•", ephemeral=True); return
                val=self.values[0]
                if val=="__none__":
                    await it.response.send_message("ÏÇ≠Ï†úÌï† Ï†úÌíàÏù¥ ÏóÜÏäµÎãàÎã§.", ephemeral=True); return
                name,cat=val.split("||",1)
                prod_delete(name, cat)
                await it.response.send_message(embed=set_v2(discord.Embed(title="Ï†úÌíà ÏÇ≠Ï†ú ÏôÑÎ£å", description=f"ÏÇ≠Ï†úÎêú Ï†úÌíà: {name} (Ïπ¥ÌÖåÍ≥†Î¶¨: {cat})", color=GRAY)), ephemeral=True)
        self.add_item(ProductDeleteSelect(owner_id))

class ControlCog(commands.Cog):
    def __init__(self, bot_:commands.Bot):
        self.bot=bot_

    @app_commands.command(name="Î≤ÑÌäºÌå®ÎÑê", description="Î≤ÑÌäº Ìå®ÎÑê")
    @app_commands.guilds(GUILD)
    async def Î≤ÑÌäºÌå®ÎÑê(self, it: discord.Interaction):
        await it.response.send_message(embed=set_v2(discord.Embed(title="ÏúàÎìú OTT", description="ÏïÑÎûò Î≤ÑÌäºÏúºÎ°ú Ïù¥Ïö©Ìï¥Ï£ºÏÑ∏Ïöî!", color=GRAY)), view=ButtonPanel())

    @app_commands.command(name="Ïπ¥ÌÖåÍ≥†Î¶¨_ÏÑ§Ï†ï", description="Ïπ¥ÌÖåÍ≥†Î¶¨ ÏÑ§Ï†ï")
    @app_commands.guilds(GUILD)
    @is_admin()
    async def Ïπ¥ÌÖåÍ≥†Î¶¨_ÏÑ§Ï†ï(self, it:discord.Interaction):
        view=discord.ui.View(timeout=None)
        class Root(discord.ui.Select):
            def __init__(self, owner_id:int):
                super().__init__(placeholder="Ïπ¥ÌÖåÍ≥†Î¶¨ ÏÑ§Ï†ïÌïòÍ∏∞", min_values=1, max_values=1,
                                 options=[discord.SelectOption(label="Ïπ¥ÌÖåÍ≥†Î¶¨ Ï∂îÍ∞Ä", value="add"),
                                          discord.SelectOption(label="Ïπ¥ÌÖåÍ≥†Î¶¨ ÏÇ≠Ï†ú", value="del")],
                                 custom_id=f"cat_root_{owner_id}")
                self.owner_id=owner_id
            async def callback(self, inter:discord.Interaction):
                if inter.user.id!=self.owner_id:
                    await inter.response.send_message("ÏûëÏÑ±ÏûêÎßå ÏÇ¨Ïö© Í∞ÄÎä•", ephemeral=True); return
                if self.values[0]=="add":
                    await inter.response.send_modal(CategorySetupModal(self.owner_id))
                else:
                    await inter.response.send_message(embed=set_v2(discord.Embed(title="Ïπ¥ÌÖåÍ≥†Î¶¨ ÏÇ≠Ï†ú", description="ÏÇ≠Ï†úÌï† Ïπ¥ÌÖåÍ≥†Î¶¨Î•º ÏÑ†ÌÉùÌïòÏÑ∏Ïöî.", color=GRAY)), view=CategoryDeleteView(self.owner_id), ephemeral=True)
        view.add_item(Root(it.user.id))
        await it.response.send_message(embed=set_v2(discord.Embed(title="Ïπ¥ÌÖåÍ≥†Î¶¨ ÏÑ§Ï†ïÌïòÍ∏∞", description="Ïπ¥ÌÖåÍ≥†Î¶¨ ÏÑ§Ï†ïÌï¥Ï£ºÏÑ∏Ïöî", color=GRAY)), view=view, ephemeral=True)

    @app_commands.command(name="Ï†úÌíà_ÏÑ§Ï†ï", description="Ï†úÌíà ÏÑ§Ï†ï")
    @app_commands.guilds(GUILD)
    @is_admin()
    async def Ï†úÌíà_ÏÑ§Ï†ï(self, it:discord.Interaction):
        view=discord.ui.View(timeout=None)
        class Root(discord.ui.Select):
            def __init__(self, owner_id:int):
                super().__init__(placeholder="Ï†úÌíà ÏÑ§Ï†ïÌïòÍ∏∞", min_values=1, max_values=1,
                                 options=[discord.SelectOption(label="Ï†úÌíà Ï∂îÍ∞Ä", value="add"),
                                          discord.SelectOption(label="Ï†úÌíà ÏÇ≠Ï†ú", value="del")],
                                 custom_id=f"prod_root_{owner_id}")
                self.owner_id=owner_id
            async def callback(self, inter:discord.Interaction):
                if inter.user.id!=self.owner_id:
                    await inter.response.send_message("ÏûëÏÑ±ÏûêÎßå ÏÇ¨Ïö© Í∞ÄÎä•", ephemeral=True); return
                if self.values[0]=="add":
                    await inter.response.send_modal(ProductSetupModal(self.owner_id))
                else:
                    await inter.response.send_message(embed=set_v2(discord.Embed(title="Ï†úÌíà ÏÇ≠Ï†ú", description="ÏÇ≠Ï†úÌï† Ï†úÌíàÏùÑ ÏÑ†ÌÉùÌïòÏÑ∏Ïöî.", color=GRAY)), view=ProductDeleteView(self.owner_id), ephemeral=True)
        view.add_item(Root(it.user.id))
        await it.response.send_message(embed=set_v2(discord.Embed(title="Ï†úÌíà ÏÑ§Ï†ïÌïòÍ∏∞", description="Ï†úÌíà ÏÑ§Ï†ïÌï¥Ï£ºÏÑ∏Ïöî", color=GRAY)), view=view, ephemeral=True)

    @app_commands.command(name="Ïû¨Í≥†_ÏÑ§Ï†ï", description="Ïû¨Í≥† ÏÑ§Ï†ï")
    @app_commands.guilds(GUILD)
    @is_admin()
    async def Ïû¨Í≥†_ÏÑ§Ï†ï(self, it:discord.Interaction):
        class StockSel(discord.ui.Select):
            def __init__(self, owner_id:int):
                ps=prod_list_all()
                opts=[]
                if ps:
                    for p in ps[:25]:
                        opts.append(discord.SelectOption(label=f"{p['name']} ({p['category']})", value=f"{p['name']}||{p['category']}", description=f"Í∞ÄÍ≤© {p['price']}"))
                else:
                    opts=[discord.SelectOption(label="Îì±Î°ùÎêú Ï†úÌíàÏù¥ ÏóÜÏäµÎãàÎã§", value="__none__")]
                super().__init__(placeholder="Ïû¨Í≥†Î•º ÏÑ§Ï†ïÌï† Ï†úÌíàÏùÑ ÏÑ†ÌÉù", min_values=1, max_values=1, options=opts, custom_id=f"stock_prod_{owner_id}")
                self.owner_id=owner_id
            async def callback(self, inter:discord.Interaction):
                if inter.user.id!=self.owner_id:
                    await inter.response.send_message("ÏûëÏÑ±ÏûêÎßå ÏÇ¨Ïö© Í∞ÄÎä•", ephemeral=True); return
                val=self.values[0]
                if val=="__none__":
                    await inter.response.send_message("Î®ºÏ†Ä Ï†úÌíàÏùÑ Ï∂îÍ∞ÄÌï¥Ï£ºÏÑ∏Ïöî.", ephemeral=True); return
                name,cat=val.split("||",1)
                await inter.response.send_modal(StockAddModal(self.owner_id, name, cat))
        view=discord.ui.View(timeout=None); view.add_item(StockSel(it.user.id))
        await it.response.send_message(embed=set_v2(discord.Embed(title="Ïû¨Í≥† ÏÑ§Ï†ïÌïòÍ∏∞", description="Ïû¨Í≥† ÏÑ§Ï†ïÌï¥Ï£ºÏÑ∏Ïöî", color=GRAY)), view=view, ephemeral=True)

    @app_commands.command(name="Î°úÍ∑∏_ÏÑ§Ï†ï", description="Î°úÍ∑∏/Î≥¥Ïïà Ï±ÑÎÑê ÏÑ§Ï†ï")
    @app_commands.guilds(GUILD)
    @is_admin()
    async def Î°úÍ∑∏_ÏÑ§Ï†ï(self, it:discord.Interaction):
        class LogChannelIdModal(discord.ui.Modal, title="Î°úÍ∑∏ Ï±ÑÎÑê ÏÑ§Ï†ï"):
            channel_id_input = discord.ui.TextInput(label="Ï±ÑÎÑê ID", required=True, max_length=25)
            def __init__(self, owner_id:int, log_key:str):
                super().__init__(); self.owner_id=owner_id; self.log_key=log_key
            async def on_submit(self, inter:discord.Interaction):
                if inter.user.id!=self.owner_id:
                    await inter.response.send_message("ÏûëÏÑ±ÏûêÎßå ÏÇ¨Ïö© Í∞ÄÎä•", ephemeral=True); return
                raw=str(self.channel_id_input.value).strip()
                if not raw.isdigit():
                    await inter.response.send_message(embed=set_v2(discord.Embed(title="Ïã§Ìå®", description="Ï±ÑÎÑê IDÎäî Ïà´Ïûê", color=RED)), ephemeral=True); return
                ch=inter.guild.get_channel(int(raw))
                if not isinstance(ch, discord.TextChannel):
                    await inter.response.send_message(embed=set_v2(discord.Embed(title="Ïã§Ìå®", description="Ïú†Ìö®Ìïú ÌÖçÏä§Ìä∏ Ï±ÑÎÑê ÏïÑÎãò", color=RED)), ephemeral=True); return
                DB["logs"].setdefault(self.log_key, {"enabled": False, "target_channel_id": None})
                DB["logs"][self.log_key]["target_channel_id"]=int(raw)
                DB["logs"][self.log_key]["enabled"]=True; db_save()
                pretty={"purchase":"Íµ¨Îß§Î°úÍ∑∏","review":"Íµ¨Îß§ÌõÑÍ∏∞","admin":"Í¥ÄÎ¶¨ÏûêÎ°úÍ∑∏","secure":"Î≥¥ÏïàÏ±ÑÎÑê"}[self.log_key]
                await inter.response.send_message(embed=set_v2(discord.Embed(title=f"{pretty} Ï±ÑÎÑê ÏßÄÏ†ï ÏôÑÎ£å", description=f"Î™©Ï†ÅÏßÄ: {ch.mention}", color=GRAY)), ephemeral=True)
        class Root(discord.ui.Select):
            def __init__(self, owner_id:int):
                options=[discord.SelectOption(label="Íµ¨Îß§Î°úÍ∑∏ ÏÑ§Ï†ï", value="purchase"),
                         discord.SelectOption(label="Íµ¨Îß§ÌõÑÍ∏∞ ÏÑ§Ï†ï", value="review"),
                         discord.SelectOption(label="Í¥ÄÎ¶¨ÏûêÎ°úÍ∑∏ ÏÑ§Ï†ï", value="admin"),
                         discord.SelectOption(label="Î≥¥ÏïàÏ±ÑÎÑê ÏÑ§Ï†ï(Ï∂©Ï†ÑÏäπÏù∏)", value="secure")]
                super().__init__(placeholder="ÏÑ§Ï†ïÌï† Î°úÍ∑∏ Ïú†Ìòï ÏÑ†ÌÉù", min_values=1, max_values=1, options=options, custom_id=f"log_root_{owner_id}")
                self.owner_id=owner_id
            async def callback(self, inter:discord.Interaction):
                if inter.user.id!=self.owner_id:
                    await inter.response.send_message("ÏûëÏÑ±ÏûêÎßå ÏÇ¨Ïö© Í∞ÄÎä•", ephemeral=True); return
                await inter.response.send_modal(LogChannelIdModal(self.owner_id, self.values[0]))
        view=discord.ui.View(timeout=None); view.add_item(Root(it.user.id))
        await it.response.send_message(embed=set_v2(discord.Embed(title="Î°úÍ∑∏ ÏÑ§Ï†ïÌïòÍ∏∞", description="Î°úÍ∑∏/Î≥¥Ïïà Ï±ÑÎÑêÏùÑ ÏÑ§Ï†ïÌï¥Ï£ºÏÑ∏Ïöî", color=GRAY)), view=view, ephemeral=True)

    @app_commands.command(name="ÏûîÏï°_ÏÑ§Ï†ï", description="ÏûîÏï° Ï∂îÍ∞Ä/Ï∞®Í∞ê")
    @app_commands.guilds(GUILD)
    @is_admin()
    @app_commands.describe(Ïú†Ï†Ä="ÎåÄÏÉÅ Ïú†Ï†Ä", Í∏àÏï°="Ï†ïÏàò Í∏àÏï°", Ïó¨Î∂Ä="Ï∂îÍ∞Ä/Ï∞®Í∞ê")
    @app_commands.choices(Ïó¨Î∂Ä=[app_commands.Choice(name="Ï∂îÍ∞Ä", value="Ï∂îÍ∞Ä"),
                               app_commands.Choice(name="Ï∞®Í∞ê", value="Ï∞®Í∞ê")])
    async def ÏûîÏï°_ÏÑ§Ï†ï(self, it:discord.Interaction, Ïú†Ï†Ä:discord.Member, Í∏àÏï°:int, Ïó¨Î∂Ä:app_commands.Choice[str]):
        if Í∏àÏï°<0:
            await it.response.send_message("Í∏àÏï°ÏùÄ ÏùåÏàò Î∂àÍ∞Ä", ephemeral=True); return
        gid=it.guild.id; uid=Ïú†Ï†Ä.id; prev=bal_get(gid, uid)
        if Ïó¨Î∂Ä.value=="Ï∞®Í∞ê":
            bal_sub(gid, uid, Í∏àÏï°); after=bal_get(gid, uid); color=RED; title=f"{Ïú†Ï†Ä} Í∏àÏï° Ï∞®Í∞ê"
        else:
            bal_add(gid, uid, Í∏àÏï°); after=bal_get(gid, uid); color=GREEN; title=f"{Ïú†Ï†Ä} Í∏àÏï° Ï∂îÍ∞Ä"
        await it.response.send_message(embed=set_v2(discord.Embed(title=title, description=f"ÏõêÎûò Í∏àÏï° : {prev}\nÎ≥ÄÍ≤Ω Í∏àÏï° : {Í∏àÏï°}\nÎ≥ÄÍ≤Ω ÌõÑ Í∏àÏï° : {after}", color=color)), ephemeral=True)

    @app_commands.command(name="Í≤∞Ï†úÏàòÎã®_ÏÑ§Ï†ï", description="Í≤∞Ï†úÏàòÎã® ÏßÄÏõê Ïó¨Î∂Ä")
    @app_commands.guilds(GUILD)
    @is_admin()
    @app_commands.describe(Í≥ÑÏ¢åÏù¥Ï≤¥="ÏßÄÏõê/ÎØ∏ÏßÄÏõê", ÏΩîÏù∏Í≤∞Ï†ú="ÏßÄÏõê/ÎØ∏ÏßÄÏõê", Î¨∏ÏÉÅÍ≤∞Ï†ú="ÏßÄÏõê/ÎØ∏ÏßÄÏõê")
    @app_commands.choices(
        Í≥ÑÏ¢åÏù¥Ï≤¥=[app_commands.Choice(name="ÏßÄÏõê", value="ÏßÄÏõê"), app_commands.Choice(name="ÎØ∏ÏßÄÏõê", value="ÎØ∏ÏßÄÏõê")],
        ÏΩîÏù∏Í≤∞Ï†ú=[app_commands.Choice(name="ÏßÄÏõê", value="ÏßÄÏõê"), app_commands.Choice(name="ÎØ∏ÏßÄÏõê", value="ÎØ∏ÏßÄÏõê")],
        Î¨∏ÏÉÅÍ≤∞Ï†ú=[app_commands.Choice(name="ÏßÄÏõê", value="ÏßÄÏõê"), app_commands.Choice(name="ÎØ∏ÏßÄÏõê", value="ÎØ∏ÏßÄÏõê")]
    )
    async def Í≤∞Ï†úÏàòÎã®_ÏÑ§Ï†ï(self, it:discord.Interaction,
                        Í≥ÑÏ¢åÏù¥Ï≤¥:app_commands.Choice[str],
                        ÏΩîÏù∏Í≤∞Ï†ú:app_commands.Choice[str],
                        Î¨∏ÏÉÅÍ≤∞Ï†ú:app_commands.Choice[str]):
        DB["payments"]["bank"]   = (Í≥ÑÏ¢åÏù¥Ï≤¥.value == "ÏßÄÏõê")
        DB["payments"]["coin"]   = (ÏΩîÏù∏Í≤∞Ï†ú.value == "ÏßÄÏõê")
        DB["payments"]["culture"]= (Î¨∏ÏÉÅÍ≤∞Ï†ú.value == "ÏßÄÏõê")
        db_save()
        await it.response.send_message(embed=set_v2(discord.Embed(title="Í≤∞Ï†úÏàòÎã® ÏÑ§Ï†ï ÏôÑÎ£å", description=f"Í≥ÑÏ¢åÏù¥Ï≤¥: {Í≥ÑÏ¢åÏù¥Ï≤¥.value}\nÏΩîÏù∏Í≤∞Ï†ú: {ÏΩîÏù∏Í≤∞Ï†ú.value}\nÎ¨∏ÏÉÅÍ≤∞Ï†ú: {Î¨∏ÏÉÅÍ≤∞Ï†ú.value}", color=GRAY)), ephemeral=True)

    @app_commands.command(name="Í≥ÑÏ¢åÎ≤àÌò∏_ÏÑ§Ï†ï", description="Í≥ÑÏ¢åÏ†ïÎ≥¥ ÏÑ§Ï†ï")
    @app_commands.guilds(GUILD)
    @is_admin()
    async def Í≥ÑÏ¢åÎ≤àÌò∏_ÏÑ§Ï†ï(self, it:discord.Interaction):
        class AccountSetupModal(discord.ui.Modal, title="Í≥ÑÏ¢åÎ≤àÌò∏ ÏÑ§Ï†ï"):
            bank_input   = discord.ui.TextInput(label="ÏùÄÌñâÎ™Ö", required=True, max_length=30)
            number_input = discord.ui.TextInput(label="Í≥ÑÏ¢åÎ≤àÌò∏", required=True, max_length=40)
            holder_input = discord.ui.TextInput(label="ÏòàÍ∏àÏ£º", required=True, max_length=30)
            def __init__(self, owner_id:int):
                super().__init__(); self.owner_id=owner_id
            async def on_submit(self, inter:discord.Interaction):
                if inter.user.id!=self.owner_id:
                    await inter.response.send_message("ÏûëÏÑ±ÏûêÎßå Í∞ÄÎä•", ephemeral=True); return
                DB["account"]["bank"]=str(self.bank_input.value).strip()
                DB["account"]["number"]=str(self.number_input.value).strip()
                DB["account"]["holder"]=str(self.holder_input.value).strip()
                db_save()
                await inter.response.send_message(embed=set_v2(discord.Embed(title="Í≥ÑÏ¢åÏ†ïÎ≥¥ Ï†ÄÏû• ÏôÑÎ£å", description=f"ÏùÄÌñâÎ™Ö `{DB['account']['bank']}`\nÍ≥ÑÏ¢åÎ≤àÌò∏ `{DB['account']['number']}`\nÏòàÍ∏àÏ£º `{DB['account']['holder']}`", color=GRAY)), ephemeral=True)
        await it.response.send_modal(AccountSetupModal(it.user.id))

    @app_commands.command(name="Ïú†Ï†Ä_ÏÑ§Ï†ï", description="Ïú†Ï†Ä Ï∞®Îã®/Ìï¥Ï†ú")
    @app_commands.guilds(GUILD)
    @is_admin()
    @app_commands.describe(Ïú†Ï†Ä="ÎåÄÏÉÅ Ïú†Ï†Ä", Ïó¨Î∂Ä="Ï∞®Îã®ÌïòÍ∏∞/Ï∞®Îã®ÌíÄÍ∏∞")
    @app_commands.choices(Ïó¨Î∂Ä=[app_commands.Choice(name="Ï∞®Îã®ÌïòÍ∏∞", value="ban"),
                               app_commands.Choice(name="Ï∞®Îã®ÌíÄÍ∏∞", value="unban")])
    async def Ïú†Ï†Ä_ÏÑ§Ï†ï(self, it:discord.Interaction, Ïú†Ï†Ä:discord.Member, Ïó¨Î∂Ä:app_commands.Choice[str]):
        gid=str(it.guild.id); uid=str(Ïú†Ï†Ä.id)
        DB["bans"].setdefault(gid, {})
        if Ïó¨Î∂Ä.value=="ban":
            DB["bans"][gid][uid]=True; db_save()
            await it.channel.send(embed=set_v2(discord.Embed(title="Ï∞®Îã®ÌïòÍ∏∞", description=f"{Ïú†Ï†Ä}ÎãòÏùÄ ÏûêÌåêÍ∏∞ Ïù¥Ïö© Î∂àÍ∞ÄÎä•", color=RED)))
            await it.response.send_message("Ï≤òÎ¶¨ ÏôÑÎ£å", ephemeral=True)
        else:
            DB["bans"][gid].pop(uid, None); db_save()
            await it.channel.send(embed=set_v2(discord.Embed(title="Ï∞®Îã®ÌíÄÍ∏∞", description=f"{Ïú†Ï†Ä}ÎãòÏùÄ Îã§Ïãú Ïù¥Ïö© Í∞ÄÎä•", color=GREEN)))
            await it.response.send_message("Ï≤òÎ¶¨ ÏôÑÎ£å", ephemeral=True)

    @app_commands.command(name="Ïú†Ï†Ä_Ï°∞Ìöå", description="Ïú†Ï†Ä Ï°∞Ìöå")
    @app_commands.guilds(GUILD)
    @is_admin()
    async def Ïú†Ï†Ä_Ï°∞Ìöå(self, it:discord.Interaction, Ïú†Ï†Ä:discord.Member):
        gid=it.guild.id; uid=Ïú†Ï†Ä.id
        ords=orders_get(gid, uid); spent=0
        for o in ords:
            p=next((pp for pp in DB["products"] if pp["name"]==o["product"]), None)
            if p: spent += p["price"]*o["qty"]
        bal=bal_get(gid, uid); pts=pt_get(gid, uid)
        await it.response.send_message(embed=set_v2(discord.Embed(title=f"{Ïú†Ï†Ä} Ï†ïÎ≥¥", description=f"Î≥¥Ïú† Í∏àÏï° : `{bal}`\nÎàÑÏ†Å Í∏àÏï° : `{spent}`\nÌè¨Ïù∏Ìä∏ : `{pts}`\nÍ±∞Îûò ÌöüÏàò : `{len(ords)}`", color=GRAY)), ephemeral=True)

    @app_commands.command(name="Ïª¨Ï≥êÎûúÎìú_ÏÑ§Ï†ï", description="Ïª¨Ï≥êÎûúÎìú Í≥ÑÏ†ï Îì±Î°ù/Í∞±Ïã†")
    @app_commands.guilds(GUILD)
    @is_admin()
    async def Ïª¨Ï≥êÎûúÎìú_ÏÑ§Ï†ï(self, it:discord.Interaction):
        await it.response.send_modal(CultureAccountModal(it.user.id))

# ===== FastAPI ÏõπÌõÖ =====
app = FastAPI()

def parse_sms_kakaobank(msg: str) -> tuple[int | None, str | None]:
    RE_AMOUNT = [re.compile(r"ÏûÖÍ∏à\s*([0-9][0-9,]*)\s*Ïõê")]
    text = str(msg or ""); amount=None
    for r in RE_AMOUNT:
        m=r.search(text)
        if m:
            raw=m.group(1).replace(",","")
            if raw.isdigit(): amount=int(raw); break
    depositor=None
    lines=[ln.strip() for ln in text.splitlines() if ln.strip()]
    for i,l in enumerate(lines):
        if l.startswith("ÏûÖÍ∏à"):
            if i+1<len(lines): depositor = lines[i+1].split()[0]
            break
    if depositor and ("ÏûîÏï°" in depositor or depositor.startswith("ÏûîÏï°")):
        depositor=None
    return amount, depositor

def parse_sms_any(msg: str) -> tuple[int | None, str | None]:
    amount=None
    m=re.search(r"([0-9][0-9,]*)\s*Ïõê", msg or "")
    if m:
        raw=m.group(1).replace(",","")
        if raw.isdigit(): amount=int(raw)
    depositor=None
    for r in [re.compile(r"ÏûÖÍ∏à\s+[0-9,]+\s*Ïõê\s+([^\s\|]+)"),
              re.compile(r"ÏûÖÍ∏àÏûê\s*[:\-]?\s*([^\s\|]+)"),
              re.compile(r"(Î≥¥ÎÇ∏Î∂Ñ|Î≥¥ÎÇ∏Ïù¥)\s*[:\-]?\s*([^\s\|]+)"),
              re.compile(r"\n([^\n\|]+)\s*(ÏûîÏï°|Ïõê|ÏûÖÍ∏à|$)")]:
        m=r.search(msg or "")
        if m:
            name=m.group(2) if (m.lastindex and m.lastindex>=2) else m.group(1)
            depositor=str(name).strip()
            break
    return amount, depositor

def parse_sms(msg: str) -> tuple[int | None, str | None]:
    a,d = parse_sms_kakaobank(msg)
    if a is None or d is None:
        a2,d2 = parse_sms_any(msg)
        if a is None: a=a2
        if d is None: d=d2
    return a,d

@app.post("/kbank-webhook")
async def kbank_webhook(req: Request):
    try:
        token=(req.headers.get("Authorization") or "").replace("Bearer","").strip()
        if token!=WEBHOOK_SECRET:
            return {"ok": False, "error":"unauthorized"}
        body=await req.json()
        gid=int(body.get("guildId") or body.get("server_id") or 0)
        msg=body.get("msg")
        amount=body.get("amount")
        depositor=body.get("depositor")
        if (amount is None or depositor is None) and isinstance(msg, str):
            a,d=parse_sms(msg)
            if amount is None: amount=a
            if depositor is None: depositor=d
        if not gid:
            return {"ok": False, "error":"guild_required"}
        guild=bot.get_guild(gid)
        if not guild:
            return {"ok": False, "error":"guild_not_found"}
        if amount is None or depositor is None:
            await send_log_text(guild, "admin", "[ÏûêÎèôÏ∂©Ï†Ñ] ÌååÏã± Ïã§Ìå®")
            return {"ok": False, "result":"parse_failed"}
        ok,msg2=await handle_deposit(guild, int(amount), str(depositor))
        return {"ok": ok, "result": msg2}
    except Exception as e:
        return {"ok": False, "error": str(e)}

def run_api():
    uvicorn.run(app, host="0.0.0.0", port=int(os.getenv("PORT","8787")), log_level="warning")

# ===== Î∂ÄÌä∏ =====
async def guild_sync(b: commands.Bot):
    try:
        await b.tree.sync(guild=GUILD)
        print("[setup_hook] Í∏∏Îìú Ïã±ÌÅ¨ ÏôÑÎ£å")
    except Exception as e:
        print(f"[setup_hook] Í∏∏Îìú Ïã±ÌÅ¨ Ïã§Ìå®: {e}")

@bot.event
async def setup_hook():
    await bot.add_cog(ControlCog(bot))
    await guild_sync(bot)

@bot.event
async def on_ready():
    print(f"Î°úÍ∑∏Ïù∏: {bot.user} (Ï§ÄÎπÑ ÏôÑÎ£å)")
    t=threading.Thread(target=run_api, daemon=True)
    t.start()

TOKEN=os.getenv("DISCORD_TOKEN", "Ïó¨Í∏∞Ïóê_ÌÜ†ÌÅ∞_ÎÑ£Í∏∞")
bot.run(TOKEN)
